
==================================================
File Path: .\i18n.py
==================================================

# File Path: .\i18n.py

import bpy

# 翻译字典：Key 是英文原始内容，Value 是对应的中文
# 你可以在这里随意添加更多翻译
TRANSLATION_DICT = {
    # --- 标题与通用 ---
    "Optimize Tools": "优化工具箱",
    "Collection Analyzer": "集合分析器",
    "View Analyzer": "视图分析器",
    "Image Resizer": "贴图缩放与管理",
    "LOD Manager": "LOD 层级管理",
    "Clean Up & Storage": "清理与存储",
    "Total": "总计",
    "Mem": "显存",
    
    # --- 按钮与操作 ---
    "Run Analyzer": "运行分析",
    "Clear Analyzer": "清除结果",
    "Scan / Refresh Images": "扫描 / 刷新图片列表",
    "Select All/None": "全选 / 反选",
    "Resize Selected Images": "缩放选中图片",
    "Original": "恢复原图",
    "Update View": "更新视图显示",
    "Reset": "重置",
    "Setup Modifiers": "安装修改器",
    "Update Geometry": "更新模型",
    "Reset Geometry": "重置模型",
    "Apply Decimate (Destructive)": "应用减面 (不可逆)",
    "Apply GeoNodes (Destructive)": "应用几何节点 (不可逆)",
    "Merge Duplicate Images (.001)": "合并重复贴图 (.001)",
    "Delete Folder": "删除文件夹",
    
    # --- 属性标签 ---
    "Method": "分析方法",
    "Color Thresholds (Vertex %)": "颜色阈值 (顶点百分比)",
    "Target": "目标尺寸",
    "Pixels": "自定义像素",
    "Safe Mode (Copy Files)": "安全模式 (另存副本)",
    "Output": "输出路径",
    "Texture Switcher (Global)": "全局贴图切换器",
    "Distance Zones (Meters)": "距离区域 (米)",
    "Viewport Optimization": "视窗显示优化",
    "Hide Far Objects": "隐藏极远物体",
    "Geometry LOD": "模型几何 LOD",
    "Enable": "启用",
    "Min Faces (Safety)": "最小面数保护",
    "Min Ratio (Max Reduction)": "最小比例 (最大减面)",
    "GN Strength Factor": "几何节点强度因子",
    "Data Cleanup": "数据清理",
    "Disk Storage Management": "磁盘存储管理",
    "Texture Optimization": "贴图优化",
    "See Image Resizer Panel below": "请查看下方的贴图缩放面板",
    "AI / Camera Optimization": "AI / 相机视角优化",
    "Auto-calculate size based on screen coverage": "基于屏幕占比自动计算尺寸",
    "Run Camera Optimization": "运行相机优化",
    "Auto-Opt": "自动优化组",
    "Camera Optimized: Generated": "相机优化完成：已生成",
    "LOD Distance Levels (For Viewport)": "LOD 距离分级 (仅影响视窗)",
    "Geometry LOD (Screen Ratio)": "几何体 LOD (屏幕占比模式)",
    "Min Ratio (Safety Floor)": "最小保留比例 (底限保护)",
    "Prevents breaking close-up details": "防止近景/特写细节丢失",
    "GN Strength Factor": "节点强度因子",
    "Higher Strength = More Merging": "强度越高 = 合并越多",
    "Edge Threshold": "边缘角度阈值",
    "Higher Angle = More Merging": "角度越大 = 合并越多 (保护越少)",
    "Update Geometry (Async)": "更新模型 (异步)",
    "High <": "高精度 <",
    "Mid <": "中精度 <",
    "Low <": "低精度 <",
    "Full": "全精度",
    "Max Merge Distance": "最大合并距离",
    "Merge Radius at furthest distance": "极远处的顶点合并半径 (值越大减面越狠)",
    
    # --- 提示信息 ---
    "(No resized sets found)": "(未找到已生成的尺寸组)",
    "Save file to see texture folders": "保存文件后可见贴图文件夹",
    "Found": "发现",
    "Texture Sets": "组贴图缓存",
}

def tr(text_key):
    """
    翻译核心函数：
    根据当前场景的语言设置，返回对应的中文或英文
    """
    # 获取上下文中的语言设置
    # 注意：为了防止在注册阶段报错，加个 try-except
    try:
        scn = bpy.context.scene.tot_props
        if scn.language == 'CN':
            return TRANSLATION_DICT.get(text_key, text_key) # 如果找不到翻译，返回原文
    except:
        pass
    
    return text_key # 默认为英文 (原文)

==================================================
File Path: .\merge.py
==================================================

import os

# 设置要生成的合并文件名
output_file = 'project_context.txt'

# 设置需要忽略的文件夹（例如 git 目录，编译目录等）
ignore_dirs = {'.git', 'node_modules', '__pycache__', 'dist', 'build', '.idea', '.vscode'}
# 设置需要读取的文件后缀（根据您的项目调整）
valid_extensions = {'.js', '.ts', '.vue', '.html', '.css', '.py', '.java', '.json', '.xml', '.go'}

with open(output_file, 'w', encoding='utf-8') as outfile:
    for root, dirs, files in os.walk('.'):
        # 过滤掉不需要的文件夹
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in files:
            if any(file.endswith(ext) for ext in valid_extensions):
                file_path = os.path.join(root, file)
                
                # 写入文件路径作为分隔符（这对 AI 理解结构至关重要）
                outfile.write(f"\n{'='*50}\n")
                outfile.write(f"File Path: {file_path}\n")
                outfile.write(f"{'='*50}\n\n")
                
                # 写入文件内容
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                        outfile.write("\n")
                except Exception as e:
                    outfile.write(f"Error reading file: {e}\n")

print(f"完成！所有代码已合并到 {output_file}，请将该文件上传给 Gemini。")

==================================================
File Path: .\properties.py
==================================================

import bpy
from bpy.props import (
    StringProperty, BoolProperty, IntProperty, FloatProperty, 
    EnumProperty, CollectionProperty, PointerProperty
)

# --- 数据项类 (Collection Items) ---
class TOT_ImageItem(bpy.types.PropertyGroup):
    tot_image_name: StringProperty()
    image_size: StringProperty()
    image_selected: BoolProperty(default=False)
    packed_img: IntProperty(default=0) # 0:File, 1:Packed, 2:Linked

# --- 主属性组 ---
class TOT_Props(bpy.types.PropertyGroup):
    language: EnumProperty(
        name="Language",
        description="Switch Interface Language",
        items=[
            ('EN', "EN", "English"),
            ('CN', "中", "中文")
        ],
        default='CN'
    )
    # ==========================================================
    # 1. 全局开关与分析器
    # ==========================================================
    CA_Toggle: BoolProperty(default=False, name="Collection Analyzer Toggle")
    AA_Toggle: BoolProperty(default=False, name="Scene Analyzer Toggle")
    
    colA_Method: EnumProperty(
        name="Method", 
        items=[('m1', 'Default', ''), ('m2', 'Advanced', '')],
        default='m1'
    )
    # 分析器阈值
    mult_veryhigh: FloatProperty(default=0.9, min=0, max=1)
    mult_high: FloatProperty(default=0.8, min=0, max=1)
    mult_medium: FloatProperty(default=0.6, min=0, max=1)
    mult_low: FloatProperty(default=0.2, min=0, max=1)
    mult_very_low: FloatProperty(default=0.0, min=0, max=1)
    
    default_col_colors: StringProperty() 
    last_shading: StringProperty()

    # 贴图管理
    image_list: CollectionProperty(type=TOT_ImageItem)
    custom_index_image_list: IntProperty()
    
    # 缩放相关
    resize_size: EnumProperty(
        name="Target Size",
        items=[
            ('128', '128 px', ''), ('256', '256 px', ''), ('512', '512 px', ''),
            ('1024', '1024 px', ''), ('2048', '2048 px', ''), ('c', 'Custom', '')
        ],
        default='1024'
    )
    custom_resize_size: IntProperty(default=1024, min=4, name="Custom Px")
    use_same_directory: BoolProperty(default=True, name="Save in Blend Dir")
    custom_output_path: StringProperty(subtype='DIR_PATH', name="Custom Path")
    duplicate_images: BoolProperty(default=True, name="Duplicate Files") # 是否另存为副本

    # 统计信息
    r_total_images: IntProperty(name="Total Images")
    total_image_memory: StringProperty(name="Total Memory")
    # ==========================================================
    # 2. LOD 管理器核心设置 (LOD Manager Core)
    # ==========================================================
    # 用于计算距离的相机
    lod_camera: PointerProperty(
        name="LOD Camera",
        description="用于计算屏幕占比的相机",
        type=bpy.types.Object,
    )
    
    lod_dist_0: FloatProperty(name="LOD 0 Distance", default=10.0, min=0.0, description="High Detail End Distance")
    lod_dist_1: FloatProperty(name="LOD 1 Distance", default=25.0, min=0.0, description="Mid Detail End Distance")
    lod_dist_2: FloatProperty(name="LOD 2 Distance", default=50.0, min=0.0, description="Low Detail End Distance")
    # ==========================================================
    # 3. 维度三：视窗优化 (Viewport Optimization)
    # ==========================================================
    view_lod_enabled: BoolProperty(
        name="Enable Viewport LOD",
        description="根据距离改变物体显示模式 (Solid/Wire/Bounds)",
        default=False,
    )
    
    # 定义显示模式枚举
    display_items = (
        ('TEXTURED', "Textured", "完整材质"),
        ('SOLID',    "Solid",    "实体显示"),
        ('WIRE',     "Wire",     "线框显示"),
        ('BOUNDS',   "Bounds",   "包围盒 (最快)"),
    )

    view_lod0_display: EnumProperty(name="L0 Display", items=display_items, default='TEXTURED')
    view_lod1_display: EnumProperty(name="L1 Display", items=display_items, default='SOLID')
    view_lod2_display: EnumProperty(name="L2 Display", items=display_items, default='WIRE')
    view_lod3_display: EnumProperty(name="L3 Display", items=display_items, default='BOUNDS')
    view_lod3_hide: BoolProperty(name="Hide at L3", description="在极远距离直接隐藏物体", default=False)

    # ==========================================================
    # 4. 维度二：模型减面 (Geometry LOD)
    # ==========================================================
    geo_lod_enabled: BoolProperty(
            name="Enable Geometry LOD",
            description="启用基于屏幕占比(Screen Ratio)的自动减面",
            default=False,
        )
    geo_lod_method: EnumProperty(
            name="LOD Method",
            items=[
                ("DECIMATE", "Decimate Modifier", "使用传统 Decimate 修改器"),
                ("GNODES", "Geometry Nodes", "使用几何节点 (高质量)"),
            ],
            default="GNODES",
        )
    
    geo_lod_min_faces: IntProperty(
        name="Min Faces", 
        default=1000, 
        min=0, 
        description="保护机制：面数少于此值的物体将不会被减面"
    )
    
    # 这个参数同时控制 Decimate 的 ratio 和 GN 的 Factor
    geo_lod_min_ratio: FloatProperty(
            name="Min Ratio Protection", 
            default=0.1, 
            min=0.01, 
            max=1.0, 
            description="最强减面保护：即使物体在极远处，也至少保留此比例的面数 (防止完全崩坏)"
        )
    # 边角阈值
    geo_lod_angle_threshold: FloatProperty(
        name="Sharpness Limit (Rad)",
        default=2.5,  # 默认值设高一点 (1.5弧度 ≈ 85度)，保证大部分面都能被合并
        min=0.0,
        max=3.14159,
        description="角度阈值：小于此角度的边缘被视为平坦区并允许合并。数值越大，减面越狠 (保护越少)。"
    )
    # 最大合并距离
    geo_lod_max_dist: FloatProperty(
        name="Max Merge Distance",
        default=0.5,   # 默认 0.5m
        min=0.001,
        max=100.0,     # 给一个足够大的上限，应对巨型场景
        description="Merge Radius at furthest distance"
    )    
# 注册列表
classes = (
    TOT_ImageItem,
    TOT_Props,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.tot_props = PointerProperty(type=TOT_Props)

def unregister():
    del bpy.types.Scene.tot_props
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\utils.py
==================================================

import bpy
from bpy_extras.object_utils import world_to_camera_view
from mathutils import Vector

def calculate_screen_coverage(scene, obj, camera):
    """
    计算物体在相机视角下的屏幕占比（像素宽度估算）。
    返回: (max_width_pixels, is_visible)
    """
    if not camera or not obj:
        return 0, False

    # 获取渲染分辨率
    render = scene.render
    res_x = render.resolution_x
    res_y = render.resolution_y
    scale = render.resolution_percentage / 100.0
    
    real_x = res_x * scale
    real_y = res_y * scale
    
    # 获取物体包围盒的 8 个顶点（世界坐标）
    bbox_corners = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]
    
    min_x, max_x = 1.0, 0.0
    min_y, max_y = 1.0, 0.0
    in_front = False

    # 将所有顶点投影到 2D 屏幕空间 (0.0 ~ 1.0)
    for corner in bbox_corners:
        co_2d = world_to_camera_view(scene, camera, corner)
        
        # co_2d.z 是深度，负数表示在相机背后
        if co_2d.z > 0:
            in_front = True
            min_x = min(min_x, co_2d.x)
            max_x = max(max_x, co_2d.x)
            min_y = min(min_y, co_2d.y)
            max_y = max(max_y, co_2d.y)
    
    # 如果所有点都在相机背后，或者物体在视野外
    if not in_front:
        return 0, False
        
    # 计算 2D 包围盒的宽高
    width = max(0.0, max_x - min_x)
    height = max(0.0, max_y - min_y)
    
    # 简单的视锥剔除：如果完全在画面外 (比如 x > 1 或 x < 0)
    # 这里做个宽松判断，因为 min_x 可能 < 0 但 max_x > 0 (跨越边界)
    if max_x < 0 or min_x > 1 or max_y < 0 or min_y > 1:
        # 虽然在相机前方，但在视锥体外面
        return 0, False

    # 转换为像素值
    pixel_width = width * real_x
    pixel_height = height * real_y
    
    # 取最长边作为分辨率参考
    return max(pixel_width, pixel_height), True

def get_normalized_screen_ratio(scene, obj, camera):
    """
    获取归一化的屏幕占比 (0.0 ~ 1.0)
    Ratio = 物体屏幕最长边像素 / 屏幕渲染长边像素
    """
    pixels, visible = calculate_screen_coverage(scene, obj, camera)
    if not visible:
        return 0.0
    
    render = scene.render
    # 取屏幕长宽的最大值作为分母
    max_screen_res = max(render.resolution_x, render.resolution_y)
    
    if max_screen_res == 0: return 0.0
    
    return min(pixels / max_screen_res, 1.0)

def get_stepped_lod_factor(raw_ratio, min_protection=0.01):
    """
    LOD 阶梯映射策略
    根据设计方案将连续的 Ratio 离散化为固定的 Factor
    """
    target_factor = 1.0
    
    # 阶梯表
    if raw_ratio > 0.8:     # 极高
        target_factor = 1.0
    elif raw_ratio > 0.5:   # 高
        target_factor = 0.7
    elif raw_ratio > 0.2:   # 中
        target_factor = 0.4
    elif raw_ratio > 0.05:  # 低
        target_factor = 0.1
    else:                   # 极低
        target_factor = 0.01 # 或者 0.0，视情况而定
        
    # 应用最小保护值 (Min Ratio)
    # 如果计算出的 target_factor 比用户设置的底限还要低，则提升至底限
    # 但如果 target_factor 本来就是 1.0 (全屏)，则不需要降低
    return max(target_factor, min_protection)

def get_collection_vertex_count(collection):
    """递归计算集合内所有 Mesh 对象的顶点总数"""
    total_verts = 0
    # 遍历集合内的所有对象
    for obj in collection.all_objects:
        if obj.type == 'MESH' and obj.data:
            total_verts += len(obj.data.vertices)
    return total_verts

def get_image_size_str(image):
    """估算图片占用的内存大小 (MB)"""
    if not image:
        return "0.00"
    
    try:
        width = image.size[0]
        height = image.size[1]
        # 估算：宽 * 高 * 4通道 (RGBA) * 深度 (通常 32bit float 或 8bit byte)
        # 这里简化按未压缩的 RGBA 8bit 估算，或者 32bit float
        # Blender 内部通常是 32bit float (4 bytes per channel)
        bytes_size = width * height * 4 * 4 
        size_mb = bytes_size / (1024 * 1024)
        return f"{size_mb:.2f}"
    except:
        return "0.00"

def format_large_number(num):
    """将大数字格式化为 K/M 后缀"""
    if num >= 1000000:
        return f"{num/1000000:.1f}M"
    elif num >= 1000:
        return f"{num/1000:.1f}K"
    else:
        return str(num)

==================================================
File Path: .\__init__.py
==================================================

import bpy
import os

ADDON_WEBSITE_URL = "https://space.bilibili.com/23411160" # 默认值
AUTHOR_NAME = "小T_sune" # 你想要显示在标题栏的名字

from . import properties
from . import ui 
from . import operators
from . import i18n

try:
    import tomllib
except ImportError:
    # 兼容低版本 Python (虽然 Blender 5.0 不会进这里)
    import pip
    # 这里不做自动安装逻辑，仅作防错
    tomllib = None


def load_manifest_info():
    """读取 manifest.toml 中的 website 字段"""
    global ADDON_WEBSITE_URL
    
    # 获取当前文件的目录
    current_dir = os.path.dirname(os.path.abspath(__file__))
    manifest_path = os.path.join(current_dir, "blender_manifest.toml")
    
    if os.path.exists(manifest_path) and tomllib:
        try:
            with open(manifest_path, "rb") as f:
                data = tomllib.load(f)
                # 读取 [information] 下的 website
                if "information" in data and "website" in data["information"]:
                    ADDON_WEBSITE_URL = data["information"]["website"]
                # 也可以顺便读取 maintainer 或 name
        except Exception as e:
            print(f"TOT Warning: Could not read manifest: {e}")


# --- 1. 兼容 Legacy Add-on (Blender < 4.2) ---
# 即使是 Extension 模式，保留这个也不会报错，旧版本则依赖它识别插件。
bl_info = {
    "name": "ToOptimize Tools (LOD Edition)",
    "author": "Your Name",
    "version": (2, 0, 0),
    "blender": (4, 2, 0), # 设置为你支持的最低版本
    "location": "View3D > Sidebar > Optimize",
    "description": "全场景性能优化：贴图、减面与视窗管理",
    "warning": "",
    "doc_url": "https://space.bilibili.com/23411160",
    "category": "3D View",
}

# 模块列表
modules = [
    i18n,
    properties,
    ui.lists,
    ui.main_panels,
    operators.analyzer,
    operators.image, 
    operators.viewport,
    operators.geometry,
    operators, 
]

def register():
    
    load_manifest_info()

    for mod in modules:
        try:
            mod.register()
        except Exception as e:
            # 打印错误但不要让插件加载完全失败，方便调试
            print(f"ToOptimize Register Error in {mod}: {e}")

def unregister():
    # --- 2. 安全卸载逻辑 ---
    # 卸载的关键是：即使出错也要继续执行，不能因为一个错误卡住整个卸载过程
    for mod in reversed(modules):
        try:
            mod.unregister()
        except Exception as e:
            print(f"ToOptimize Unregister Error in {mod}: {e}")
            pass # 强制继续卸载下一个模块

    # 清理可能残留的属性 (防止下次加载报错)
    if hasattr(bpy.types.Scene, "tot_props"):
        del bpy.types.Scene.tot_props

==================================================
File Path: .\operators\analyzer.py
==================================================

import bpy
from .. import utils
import webbrowser

class TOT_OT_CollectionAnalyzer(bpy.types.Operator):
    """根据顶点数标记集合颜色并显示百分比"""
    bl_idname = "tot.collectionanalyzer"
    bl_label = "Run Analyzer"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        # 1. 强制清理旧状态
        bpy.ops.tot.cleancolors()

        self.report({'INFO'}, "Analyzing Collections...")
        
        # 2. 获取参数
        if scn.colA_Method == 'm1':
            m_vhigh, m_high, m_med, m_low = 0.9, 0.8, 0.6, 0.2
        else:
            m_vhigh = scn.mult_veryhigh
            m_high = scn.mult_high
            m_med = scn.mult_medium
            m_low = scn.mult_low

        backup = {}
        scene_total_verts = 0
        max_col_verts = 0

        # 3. 统计全场景
        for obj in context.view_layer.objects:
            if obj.type == 'MESH':
                 scene_total_verts += len(obj.data.vertices) # 简单统计，为了速度
        
        if scene_total_verts == 0: scene_total_verts = 1 # 防止除以0

        # 4. 遍历集合
        for col in bpy.data.collections:
            # 备份原始颜色
            backup[col.name] = col.color_tag
            col.color_tag = 'NONE' # 重置

            # 计算该集合顶点数
            v_count = utils.get_collection_vertex_count(col)
            if v_count > max_col_verts: max_col_verts = v_count

            # 只有当集合有东西时才处理
            if v_count > 0:
                # 4.1 重命名：增加百分比后缀
                percent = (v_count / scene_total_verts) * 100.0
                col.name = f"{col.name} | {percent:.1f}%"

                # 4.2 颜色判定 (相对于场景中最大的集合，或者固定阈值? 旧逻辑是用 max_col_verts 作为基准)
                # 但旧逻辑是在循环里动态更新 highest_col，这里为了准确，应该用 scene_total_verts 或预设大数值
                # 这里采用：基于当前集合占总场景的比例，或者基于绝对数量。
                # 移植 v2 逻辑：它是动态对比 highest_col (但在循环里 highest 还没算完)。
                # 让我们改良一下：使用 v_count / scene_total_verts 的比例来染色会更直观。
                # 或者使用绝对数量 (比如 100万面)。这里为了复刻 v2 效果，我们简化逻辑：
                
                # 假设基准：如果占场景总量的比例超过阈值
                ratio = v_count / scene_total_verts
                
                # 这里稍微调整逻辑以适应滑块：
                # 如果我们把滑块当做百分比阈值 (0.9 = 90% vertices)
                if ratio >= m_vhigh: col.color_tag = 'COLOR_01'   # Red
                elif ratio >= m_high: col.color_tag = 'COLOR_02'  # Orange
                elif ratio >= m_med: col.color_tag = 'COLOR_03'   # Yellow
                elif ratio >= m_low: col.color_tag = 'COLOR_04'   # Green
                else: col.color_tag = 'COLOR_05'                  # Blue

        # 保存备份
        scn.default_col_colors = str(backup)
        scn.CA_Toggle = True 
        return {'FINISHED'}

class TOT_OT_CleanColors(bpy.types.Operator):
    """恢复集合名称和颜色"""
    bl_idname = "tot.cleancolors"
    bl_label = "Clear Analyzer"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        # 读取备份
        data = {}
        if scn.default_col_colors:
            try: data = eval(scn.default_col_colors)
            except: pass

        for col in bpy.data.collections:
            # 1. 还原名字 (去除 " | 10.5%" 这种后缀)
            if ' | ' in col.name:
                col.name = col.name.split(' | ')[0].strip()
            
            # 2. 还原颜色
            if col.name in data:
                col.color_tag = data[col.name]
            else:
                col.color_tag = 'NONE'

        scn.CA_Toggle = False
        scn.default_col_colors = ""
        return {'FINISHED'}

# ... (ViewAnalyzer Code stays roughly the same) ...
class TOT_OT_ViewAnalyzer(bpy.types.Operator):
    bl_idname = "tot.viewanalyzer"
    bl_label = "Run 3D View Analyzer"
    def execute(self, context):
        scn = context.scene.tot_props
        if context.space_data.type == 'VIEW_3D':
            scn.last_shading = context.space_data.shading.color_type
            context.space_data.shading.type = 'SOLID'
            context.space_data.shading.color_type = 'OBJECT'
        
        # 简单染色逻辑
        max_v = 1
        mesh_objs = [o for o in context.view_layer.objects if o.type == 'MESH']
        for o in mesh_objs:
            if len(o.data.vertices) > max_v: max_v = len(o.data.vertices)
        
        from mathutils import Color
        for o in mesh_objs:
            ratio = len(o.data.vertices) / max_v
            # 红色(Hue 0)到蓝色(Hue 0.66)
            c = Color()
            c.hsv = (0.66 * (1.0 - ratio), 1.0, 1.0)
            o.color = (c.r, c.g, c.b, 1.0)

        scn.AA_Toggle = True
        return {'FINISHED'}

class TOT_OT_CleanViewAnalyzer(bpy.types.Operator):
    bl_idname = "tot.cleanviewanalyzer"
    bl_label = "Clear View Analyzer"
    def execute(self, context):
        scn = context.scene.tot_props
        if context.space_data.type == 'VIEW_3D':
            target = scn.last_shading if scn.last_shading else 'MATERIAL'
            context.space_data.shading.color_type = target
        
        # 恢复物体白色
        for o in context.view_layer.objects:
            o.color = (1,1,1,1)

        scn.AA_Toggle = False
        return {'FINISHED'}

class TOT_OT_OpenWebsite(bpy.types.Operator):
    """访问作者主页 / 教程"""
    bl_idname = "tot.open_website"
    bl_label = "Open Website"
    
    def execute(self, context):
        # 从 __init__ 导入全局变量
        # 注意：使用相对导入获取包层级的变量
        from .. import ADDON_WEBSITE_URL
        
        if ADDON_WEBSITE_URL:
            webbrowser.open(ADDON_WEBSITE_URL)
            self.report({'INFO'}, f"Opening: {ADDON_WEBSITE_URL}")
        else:
            self.report({'WARNING'}, "No website URL configured.")
            
        return {'FINISHED'}


classes = (
    TOT_OT_CollectionAnalyzer,
    TOT_OT_CleanColors, 
    TOT_OT_ViewAnalyzer,
    TOT_OT_CleanViewAnalyzer,
    TOT_OT_OpenWebsite,
        )

def register():
    for cls in classes: bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes): bpy.utils.unregister_class(cls)


    """访问作者主页 / 教程"""
    bl_idname = "tot.open_website"
    bl_label = "Open Website"
    
    def execute(self, context):
        # 从 __init__ 导入全局变量
        # 注意：使用相对导入获取包层级的变量
        from .. import ADDON_WEBSITE_URL
        
        if ADDON_WEBSITE_URL:
            webbrowser.open(ADDON_WEBSITE_URL)
            self.report({'INFO'}, f"Opening: {ADDON_WEBSITE_URL}")
        else:
            self.report({'WARNING'}, "No website URL configured.")
            
        return {'FINISHED'}

==================================================
File Path: .\operators\geometry.py
==================================================

import bpy
import time
import math
from mathutils import Vector
from .. import utils

# =============================================================================
# 常量定义
# =============================================================================
DECIMATE_MOD_NAME = "TOT_LOD_DECIMATE"
GEO_NODES_MOD_NAME = "TOT_GEO_LOD"
GN_INPUT_FACTOR = "LOD_Factor"      # 接口1：强度
GN_INPUT_ANGLE = "Angle_Threshold" 
GN_INPUT_MAX_DIST = "Max_Merge_Dist" # 接口2：角度阈值

# =============================================================================
# Helper: 几何节点组构建
# =============================================================================
def ensure_lod_node_group():
    """
    创建/更新 LOD 节点组 (Geometry Nodes)
    功能：
    1. 接收 LOD_Factor (0.0~1.0) 和 Angle_Threshold
    2. 接收 Max_Merge_Dist (最大合并距离)
    3. 根据 Factor 动态计算合并距离：离得越远(Factor越小)，合并半径越大
    4. 保护锐利边缘，只合并平坦区域
    """
    name = "TOT_GEO_LOD_Advanced" 
    group = bpy.data.node_groups.get(name)
    
    if not group:
        group = bpy.data.node_groups.new(name=name, type="GeometryNodeTree")
    
    # -----------------------------------------------------------
    # 内嵌辅助函数：安全创建节点
    # -----------------------------------------------------------
    def safe_create_node(nodes, possible_names, label=None):
        for node_name in possible_names:
            try:
                node = nodes.new(node_name)
                if label: node.label = label
                return node
            except Exception:
                continue
        return None
    # -----------------------------------------------------------

    # ===========================================================
    # 1. 定义接口 (Interface) - 确保输入输出端口存在
    # ===========================================================
    if hasattr(group, "interface"):
        # 注意：这里我们只在初始化或不匹配时清理，或者简单地追加
        # 为了代码简洁，这里假设每次重建接口，实际生产中可优化
        group.interface.clear()
        
        # [0] Geometry In
        group.interface.new_socket(name="Geometry", in_out='INPUT', socket_type='NodeSocketGeometry')
        
        # [1] LOD_Factor (0.0 = 远/低模, 1.0 = 近/高模)
        s1 = group.interface.new_socket(name=GN_INPUT_FACTOR, in_out='INPUT', socket_type='NodeSocketFloat')
        s1.min_value = 0.0
        s1.max_value = 1.0
        s1.default_value = 1.0
        
        # [2] Angle_Threshold (弧度，用于保护边缘)
        s2 = group.interface.new_socket(name=GN_INPUT_ANGLE, in_out='INPUT', socket_type='NodeSocketFloat')
        s2.min_value = 0.0
        s2.max_value = 3.14159
        s2.default_value = 1.5 
        
        # [3] Max_Merge_Dist (新参数：最远处的合并半径)
        # 即使你在外部没定义常量 GN_INPUT_MAX_DIST，这里用字符串也行
        dist_name = "Max_Merge_Dist" 
        if "GN_INPUT_MAX_DIST" in globals(): dist_name = GN_INPUT_MAX_DIST
            
        s3 = group.interface.new_socket(name=dist_name, in_out='INPUT', socket_type='NodeSocketFloat')
        s3.min_value = 0.0
        s3.default_value = 0.5 # 默认最大合并 0.5m
        
        # [0] Geometry Out
        group.interface.new_socket(name="Geometry", in_out='OUTPUT', socket_type='NodeSocketGeometry')

    nodes = group.nodes
    links = group.links
    nodes.clear()

    # ===========================================================
    # 2. 创建节点
    # ===========================================================
    
    # 输入输出节点
    n_in = nodes.new("NodeGroupInput")
    n_in.location = (-900, 0)
    
    n_out = nodes.new("NodeGroupOutput")
    n_out.location = (600, 0)

    # [Merge By Distance] - 核心减面节点
    n_merge = safe_create_node(
        nodes, 
        ["GeometryNodeMergeByDistance", "GeometryNodeMeshMergeByDistance"], 
        label="Merge by Distance"
    )
    if not n_merge: raise RuntimeError("Missing Merge Node")
    n_merge.location = (300, 0)
    
    # [Map Range] - 动态距离控制核心
    # 逻辑：将 LOD_Factor (0~1) 映射为 Distance (Max~Min)
    # 当 Factor=1 (近景) -> Distance=0 (不合并)
    # 当 Factor=0 (远景) -> Distance=Max_Merge_Dist (强合并)
    n_map_dist = nodes.new("ShaderNodeMapRange") 
    n_map_dist.label = "Dynamic Distance"
    n_map_dist.location = (50, -250)
    
    n_map_dist.inputs['From Min'].default_value = 0.0   # Factor 0 (远)
    n_map_dist.inputs['From Max'].default_value = 1.0   # Factor 1 (近)
    # To Min 将由外部输入的 Max_Dist 控制
    n_map_dist.inputs['To Max'].default_value = 0.0001  # 近处几乎不合并

    # [Edge Angle] - 边缘检测
    n_edge_angle = safe_create_node(
        nodes, 
        [
            "GeometryNodeInputMeshEdgeAngle", 
            "GeometryNodeEdgeAngle", 
            "GeometryNodeMeshEdgeAngle", 
            "GeometryNodeInputEdgeAngle"
        ],
        label="Edge Angle"
    )

    # ===========================================================
    # 3. 连线逻辑
    # ===========================================================

    if n_edge_angle:
        # --- 如果版本支持 Edge Angle (高级模式) ---
        n_edge_angle.location = (-600, 250)

        # [Compare] Is Flat? (判断当前边是否平坦)
        n_is_flat = nodes.new("FunctionNodeCompare")
        n_is_flat.data_type = 'FLOAT'
        n_is_flat.operation = 'LESS_THAN'
        n_is_flat.label = "Is Flat?"
        n_is_flat.location = (-350, 250)

        # [Math] 1.0 - LOD (反转 Factor 用于随机概率)
        n_invert = nodes.new("ShaderNodeMath")
        n_invert.operation = 'SUBTRACT'
        n_invert.label = "1.0 - LOD"
        n_invert.inputs[0].default_value = 1.0
        n_invert.location = (-600, -150)

        # [Random] 随机筛选点
        n_random = nodes.new("FunctionNodeRandomValue")
        n_random.data_type = 'BOOLEAN'
        n_random.label = "Random Cull"
        n_random.location = (-350, -150)

        # [Boolean And] 综合条件：既要平坦，又要命中随机概率
        n_and = nodes.new("FunctionNodeBooleanMath")
        n_and.operation = 'AND'
        n_and.label = "Filter"
        n_and.location = (-100, 100)

        # --- 连线 A: 选点逻辑 (Selection) ---
        # 1. 边缘角度 < 阈值 ?
        links.new(n_edge_angle.outputs[0], n_is_flat.inputs[0])
        links.new(n_in.outputs[2], n_is_flat.inputs[1]) # Input[2] is Angle_Threshold

        # 2. 随机概率 = 1 - LOD
        links.new(n_in.outputs[1], n_invert.inputs[1])  # Input[1] is LOD_Factor
        links.new(n_invert.outputs[0], n_random.inputs["Probability"])

        # 3. 组合条件
        links.new(n_is_flat.outputs[0], n_and.inputs[0])
        links.new(n_random.outputs[3], n_and.inputs[1]) # Random Boolean Output is index 3

        # 4. 连入 Merge Selection
        try:
            target_socket = n_merge.inputs.get("Selection") or n_merge.inputs[1]
            links.new(n_and.outputs[0], target_socket)
        except: pass

        # --- 连线 B: 动态距离逻辑 (Distance) ---
        # 1. Input[1] (Factor) -> Map Range Value
        links.new(n_in.outputs[1], n_map_dist.inputs['Value'])
        
        # 2. Input[3] (Max_Dist) -> Map Range 'To Min' (对应 Factor 0 也就是最远处的距离)
        # 注意：这里假设输入顺序是 [Geo, Factor, Angle, MaxDist] -> Index 3
        links.new(n_in.outputs[3], n_map_dist.inputs['To Min'])
        
        # 3. Map Range Result -> Merge Distance
        links.new(n_map_dist.outputs['Result'], n_merge.inputs['Distance'])

    else:
        # --- 降级模式 (Fallback) ---
        # 注意缩进：这里的 else 是对应最外层的 if n_edge_angle
        print("[TOT] No Edge Angle node found. Fallback mode.")
        
        # 即使在降级模式，我们也尝试连接动态距离，这样至少能在不考虑边缘的情况下大幅减面
        try:
             # Input[1] Factor -> Map Range
             links.new(n_in.outputs[1], n_map_dist.inputs['Value'])
             # Input[3] MaxDist -> Map Range To Min
             links.new(n_in.outputs[3], n_map_dist.inputs['To Min'])
             # Map Range -> Merge Distance
             links.new(n_map_dist.outputs['Result'], n_merge.inputs['Distance'])
        except:
             pass
             
        # 只有几何流连接，不连接 Selection（全选）
        links.new(n_in.outputs[0], n_merge.inputs[0]) 

    # ===========================================================
    # 4. 主几何流连线 (Common)
    # ===========================================================
    in_geo = n_in.outputs[0]
    out_geo = n_out.inputs[0]
    merge_geo_in = n_merge.inputs.get("Geometry") or n_merge.inputs[0]
    merge_geo_out = n_merge.outputs.get("Geometry") or n_merge.outputs[0]

    # 注意：如果上面连了，这里重复连没关系，Blender 会覆盖
    # 但在高级模式下，Selection 已经筛选了点，这里只需连 Geometry
    if not n_edge_angle:
        # 降级模式下直接连
        pass 
    
    links.new(in_geo, merge_geo_in)
    links.new(merge_geo_out, out_geo)

    return group

def get_input_identifier(node_group, input_name):
    if not node_group: return None
    if hasattr(node_group, "interface"):
        for item in node_group.interface.items_tree:
            if item.item_type == 'SOCKET' and item.in_out == 'INPUT':
                if item.name == input_name:
                    return item.identifier
    elif hasattr(node_group, "inputs"):
        for input_socket in node_group.inputs:
            if input_socket.name == input_name:
                return input_socket.identifier
    return None

# =============================================================================
# Operators
# =============================================================================

class TOT_OT_GeoLODSetup(bpy.types.Operator):
    """Setup Geometry LOD Modifiers"""
    bl_idname = "tot.geo_lod_setup"
    bl_label = "Setup Modifiers"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        method = scn.geo_lod_method
        min_faces = scn.geo_lod_min_faces
        
        created = 0
        try:
            lod_group = ensure_lod_node_group() if method == 'GNODES' else None
        except Exception as e:
            self.report({'ERROR'}, f"Create Node Error: {e}")
            return {'CANCELLED'}
        
        for obj in context.scene.objects:
            if obj.type != 'MESH': continue
            if min_faces > 0 and len(obj.data.polygons) < min_faces: continue
            
            if method == 'DECIMATE':
                if obj.modifiers.get(GEO_NODES_MOD_NAME):
                    obj.modifiers.remove(obj.modifiers.get(GEO_NODES_MOD_NAME))
                mod = obj.modifiers.get(DECIMATE_MOD_NAME)
                if not mod:
                    mod = obj.modifiers.new(DECIMATE_MOD_NAME, 'DECIMATE')
                    mod.decimate_type = 'COLLAPSE'
                    mod.ratio = 1.0
                    obj["_tot_geo_lod_created"] = True
                    created += 1
                    
            elif method == 'GNODES':
                if obj.modifiers.get(DECIMATE_MOD_NAME):
                    obj.modifiers.remove(obj.modifiers.get(DECIMATE_MOD_NAME))

                mod = obj.modifiers.get(GEO_NODES_MOD_NAME)
                force_rebuild = False
                if mod and mod.node_group and mod.node_group.name != "TOT_GEO_LOD_Advanced":
                    force_rebuild = True
                if mod and len(mod.node_group.interface.items_tree) != len(lod_group.interface.items_tree):
                    force_rebuild = True

                if not mod or force_rebuild:
                    if mod: obj.modifiers.remove(mod)
                    mod = obj.modifiers.new(name=GEO_NODES_MOD_NAME, type='NODES')
                    mod.node_group = lod_group
                    obj["_tot_geo_lod_created"] = True
                    created += 1
                
                gn_id_angle = get_input_identifier(lod_group, GN_INPUT_ANGLE)
                if gn_id_angle:
                    mod[gn_id_angle] = scn.geo_lod_angle_threshold
                
                gn_id_dist = get_input_identifier(lod_group, GN_INPUT_MAX_DIST)
                if gn_id_dist:
                     mod[gn_id_dist] = scn.geo_lod_max_dist # 从面板读取值

        self.report({'INFO'}, f"Setup complete: {created} modifiers updated.")
        return {'FINISHED'}

class TOT_OT_GeoLODUpdateAsync(bpy.types.Operator):
    """
    异步计算屏幕占比并更新 LOD 修改器
    """
    bl_idname = "tot.geo_lod_update_async"
    bl_label = "Update Geometry (Async)"
    bl_options = {'REGISTER', 'UNDO'}

    _timer = None
    _queue = []
    _total_tasks = 0
    _processed = 0
    _updated_count = 0
    TIME_BUDGET = 0.05   #帧时间

    def modal(self, context, event):
        if event.type == 'TIMER':
            if not self._queue: return self.finish(context)
            start_time = time.time()
            while self._queue:
                obj = self._queue.pop(0)
                try: self.process_object(context, obj)
                except: pass
                self._processed += 1
                if (time.time() - start_time) > self.TIME_BUDGET: break
            context.window_manager.progress_update(self._processed)
        return {'PASS_THROUGH'}

    def invoke(self, context, event):
        scn = context.scene.tot_props
        if not scn.geo_lod_enabled: return {'CANCELLED'}
        self.cam = scn.lod_camera or context.scene.camera
        if not self.cam: 
            self.report({'ERROR'}, "No Camera found.")
            return {'CANCELLED'}
            
        method = scn.geo_lod_method
        target_mod = DECIMATE_MOD_NAME if method == 'DECIMATE' else GEO_NODES_MOD_NAME
        
        self._queue = []
        for obj in context.scene.objects:
            if obj.type == 'MESH' and not obj.hide_viewport:
                if obj.modifiers.get(target_mod):
                    self._queue.append(obj)
        
        if not self._queue:
            self.report({'WARNING'}, "Run 'Setup' first.")
            return {'CANCELLED'}

        self._total_tasks = len(self._queue)
        self._processed = 0
        self._updated_count = 0
        self.method = method
        self.min_protection = scn.geo_lod_min_ratio
        
        self.angle_threshold = scn.geo_lod_angle_threshold
        self.max_dist = scn.geo_lod_max_dist
        
        self.gn_id_factor = None
        self.gn_id_angle = None
        self.gn_id_dist = None
        
        if method == 'GNODES':
            group = bpy.data.node_groups.get("TOT_GEO_LOD_Advanced")
            self.gn_id_factor = get_input_identifier(group, GN_INPUT_FACTOR)
            self.gn_id_angle = get_input_identifier(group, GN_INPUT_ANGLE)

        context.window_manager.progress_begin(0, self._total_tasks)
        self._timer = context.window_manager.event_timer_add(0.01, window=context.window) 
        context.window_manager.modal_handler_add(self)
        
        return {'RUNNING_MODAL'}

    def process_object(self, context, obj):
        """
        处理单个物体的 LOD 更新逻辑：
        1. 计算屏幕占比 (Screen Ratio)
        2. 转换为阶梯化的 LOD Factor
        3. 将参数写入修改器 (Decimate 或 GeometryNodes)
        """
        # ===========================================================
        # 1. 计算原始屏幕占比 (Raw Screen Ratio)
        # ===========================================================
        if hasattr(utils, 'get_normalized_screen_ratio'):
            raw_ratio = utils.get_normalized_screen_ratio(context.scene, obj, self.cam)
        else:
            raw_ratio = 0.5 # 默认兜底值，防止 utils 未加载报错
        
        # ===========================================================
        # 2. 阶梯化处理 (Stepping)
        # ===========================================================
        # 为了防止数值频繁微变导致 Blender 每帧都刷新几何体 (引起卡顿)
        # 我们只在 Ratio 跨越特定台阶时才改变 Factor
        if hasattr(utils, 'get_stepped_lod_factor'):
            target_factor = utils.get_stepped_lod_factor(raw_ratio, self.min_protection)
        else:
            target_factor = 1.0

        # ===========================================================
        # 3. 应用到修改器 (Apply Modifiers)
        # ===========================================================
        
        # --- 模式 A: 传统减面修改器 (Decimate) ---
        if self.method == 'DECIMATE':
            mod = obj.modifiers.get(DECIMATE_MOD_NAME)
            # 只有当新旧值的差超过 0.05 时才写入，减少无效更新
            if mod and abs(mod.ratio - target_factor) > 0.05:
                mod.ratio = target_factor
                obj.update_tag() # [重要] 强制通知 Blender 这个物体数据变了，需要重绘
                self._updated_count += 1
                    
        # --- 模式 B: 几何节点 (Geometry Nodes) ---
        elif self.method == 'GNODES':
            mod = obj.modifiers.get(GEO_NODES_MOD_NAME)
            if mod:
                # 标记是否有变化，如果有任何一个参数变了，最后统一刷新
                changed = False
                
                # 3.1 更新强度 (LOD_Factor)
                # ---------------------------------------------------
                # 控制随机删面的比例 (0~1)
                if self.gn_id_factor:
                    try:
                        curr = mod.get(self.gn_id_factor, 1.0)
                        # 同样使用 0.05 的死区阈值，避免频繁闪烁
                        if abs(curr - target_factor) > 0.05:
                            mod[self.gn_id_factor] = target_factor
                            changed = True
                    except: pass
                
                # 3.2 更新角度阈值 (Angle_Threshold)
                # ---------------------------------------------------
                # 控制平坦区域的判断标准 (从面板读取的全局设置)
                if self.gn_id_angle:
                    try:
                        curr_angle = mod.get(self.gn_id_angle, 1.5)
                        # 检查当前值与全局设置的差异
                        if abs(curr_angle - self.angle_threshold) > 0.01:
                            mod[self.gn_id_angle] = self.angle_threshold
                            changed = True
                    except: pass

                # 3.3 [新增] 更新最大合并距离 (Max_Merge_Dist)
                # ---------------------------------------------------
                # 控制极远距离下的塌陷力度 (从面板读取的全局设置)
                # 只有当 invoke 中成功获取到 id 且属性存在时才执行
                if hasattr(self, 'gn_id_dist') and self.gn_id_dist:
                    try:
                        # 获取当前物体上存储的距离值 (默认0.5)
                        curr_dist = mod.get(self.gn_id_dist, 0.5)
                        
                        # 获取目标值 (self.max_dist 在 invoke 中从 scn.geo_lod_max_dist 读取)
                        # 使用 getattr 防止旧版本 invoke 没有定义 max_dist 导致报错
                        target_dist = getattr(self, 'max_dist', 0.5) 
                        
                        if abs(curr_dist - target_dist) > 0.001:
                            mod[self.gn_id_dist] = target_dist
                            changed = True
                    except: pass
                
                # 4. 提交更改
                # ---------------------------------------------------
                # [核心优化] 只有数值真正改变时，才强制刷新物体
                # 避免在大场景中即使数值没变也触发 update_tag，导致不必要的性能消耗
                if changed:
                    obj.update_tag() 
                    self._updated_count += 1
    def finish(self, context):
        context.window_manager.event_timer_remove(self._timer)
        context.window_manager.progress_end()
        for win in context.window_manager.windows:
            for area in win.screen.areas:
                if area.type == 'VIEW_3D': area.tag_redraw()
        self.report({'INFO'}, f"Updated {self._updated_count} objects.")
        return {'FINISHED'}

class TOT_OT_GeoLODReset(bpy.types.Operator):
    bl_idname = "tot.geo_lod_reset"
    bl_label = "Reset Geometry"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        removed = 0
        for obj in context.scene.objects:
            if obj.modifiers.get(DECIMATE_MOD_NAME): 
                obj.modifiers.remove(obj.modifiers.get(DECIMATE_MOD_NAME)); removed+=1
            if obj.modifiers.get(GEO_NODES_MOD_NAME): 
                obj.modifiers.remove(obj.modifiers.get(GEO_NODES_MOD_NAME)); removed+=1
            if "_tot_geo_lod_created" in obj: del obj["_tot_geo_lod_created"]
        self.report({'INFO'}, f"Reset {removed} objects.")
        return {'FINISHED'}

class TOT_OT_GeoLODApply(bpy.types.Operator):
    bl_idname = "tot.geo_lod_apply"
    bl_label = "Apply (Destructive)"
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        return {'FINISHED'}

classes = (
    TOT_OT_GeoLODSetup,
    TOT_OT_GeoLODUpdateAsync,
    TOT_OT_GeoLODReset,
    TOT_OT_GeoLODApply,
)

def register():
    for cls in classes: bpy.utils.register_class(cls)
def unregister():
    for cls in reversed(classes): bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\image.py
==================================================

import os
import re
import bpy
import shutil
from .. import utils 
import time

class TOT_OT_UpdateImageList(bpy.types.Operator):
    bl_idname = "tot.updateimagelist"
    bl_label = "Update Image List"
    
    def execute(self, context):
        scn = context.scene.tot_props
        scn.image_list.clear()
        
        total_size_mb = 0.0
        count = 0
        
        for img in bpy.data.images:
            # 排除渲染结果和浏览器节点
            if img.name in {'Render Result', 'Viewer Node'}: continue
            # 排除生成的图片 (Generated) 通常不需要压缩
            if img.source == 'GENERATED': continue

            item = scn.image_list.add()
            item.tot_image_name = img.name
            
            # 状态检查
            if img.packed_file:
                item.packed_img = 1 # Packed
            elif img.library:
                item.packed_img = 2 # Linked
            else:
                item.packed_img = 0 # File
            
            # 计算大小
            size_str = utils.get_image_size_str(img)
            item.image_size = size_str
            total_size_mb += float(size_str)
            
            count += 1
            
        scn.r_total_images = count
        scn.total_image_memory = f"{total_size_mb:.2f}"
        
        return {'FINISHED'}

class TOT_OT_SelectAllImages(bpy.types.Operator):
    bl_idname = "tot.imglistselectall"
    bl_label = "Select All"
    
    def execute(self, context):
        scn = context.scene.tot_props
        # 智能反选
        has_unselected = any(not i.image_selected for i in scn.image_list)
        for i in scn.image_list:
            i.image_selected = has_unselected
        return {'FINISHED'}

class TOT_OT_ResizeImages(bpy.types.Operator):
    bl_idname = "tot.resizeimages"
    bl_label = "Resize Images"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        base_path = bpy.path.abspath("//")
        if not base_path:
            self.report({'ERROR'}, "Please save the .blend file first!")
            return {'CANCELLED'}

        # 获取目标尺寸
        if scn.resize_size == 'c':
            target_size = scn.custom_resize_size
        else:
            target_size = int(scn.resize_size)

        # --- [逻辑修改] 动态生成文件夹名称 ---
        folder_name = f"textures_{target_size}px" 
        
        # 决定最终路径
        if scn.duplicate_images and not scn.use_same_directory:
            # 如果用户指定了自定义路径，就在自定义路径下创建 textures_1024px
            output_dir = os.path.join(bpy.path.abspath(scn.custom_output_path), folder_name)
        else:
            # 默认在 blend 文件旁边的 textures_1024px
            output_dir = os.path.join(base_path, folder_name)

        if not os.path.exists(output_dir):
            try:
                os.makedirs(output_dir)
            except Exception as e:
                self.report({'ERROR'}, f"Cannot create directory: {e}")
                return {'CANCELLED'}

        resized_count = 0
        
        for item in scn.image_list:
            if not item.image_selected: continue

            img = bpy.data.images.get(item.tot_image_name)
            if not img: continue
            if img.source in {'VIEWER', 'GENERATED'}: continue
            
            # 即使原图比目标小，为了统一管理，建议也处理，或者你可以保留这个判断
            if img.size[0] <= target_size and img.size[1] <= target_size:
                # continue # 如果你想跳过小图，取消注释
                pass 

            try:
                # 0. 记录原始路径
                if "tot_original_path" not in img:
                    img["tot_original_path"] = img.filepath
                # 1. 构造文件名
                original_filepath = img.filepath_from_user()
                file_name = os.path.basename(original_filepath)
                if not file_name: file_name = f"{img.name}.png"
                
                name_part, ext_part = os.path.splitext(file_name)
                if not ext_part: ext_part = ".png"
                
                # 新文件名: my_texture_1024px.jpg
                new_file_name = f"{name_part}_{target_size}px{ext_part}"
                new_full_path = os.path.join(output_dir, new_file_name)
                
                # 2. 内存缩放
                img.scale(target_size, target_size)
                
                # 3. 物理保存
                img.save_render(filepath=new_full_path)
                
                # 4. 重连并刷新
                img.filepath = new_full_path
                img.reload()
                
                resized_count += 1

            except Exception as e:
                self.report({'ERROR'}, f"Error processing {img.name}: {e}")

        # 刷新列表
        bpy.ops.tot.updateimagelist()
        
        # 强制刷新 UI (为了让 Clean Up 面板立马显示新文件夹)
        context.area.tag_redraw()
        
        self.report({'INFO'}, f"Optimized {resized_count} textures into folder: {folder_name}")
        return {'FINISHED'}

class TOT_OT_ClearDuplicateImage(bpy.types.Operator):
    """清理重复贴图：将 .001, .002 结尾的图片替换为原始图片"""
    bl_idname = "tot.clearduplicateimage"
    bl_label = "Clear Duplicate Images"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        cleaned_count = 0
        
        # 1. 建立映射表：{"Image.001": "Image", "Texture.002": "Texture"}
        # 仅当不带后缀的原始图片存在时才进行替换
        remap_dict = {} # Key: Duplicate Name, Value: Original Image Object
        
        # 获取所有图片
        all_images = list(bpy.data.images)
        
        for img in all_images:
            # 检查名字是否类似 "Name.001"
            if len(img.name) > 4 and img.name[-4] == '.' and img.name[-3:].isdigit():
                base_name = img.name[:-4] # 移除后缀
                
                # 查找是否存在原始图片
                original_img = bpy.data.images.get(base_name)
                
                # 只有当原始图片存在，且不是同一个对象时
                if original_img and original_img != img:
                    # 也可以加一层校验：比如文件路径是否一致，防止误杀同名不同图
                    # 这里简化逻辑：名字匹配即替换
                    remap_dict[img.name] = original_img

        if not remap_dict:
            self.report({'INFO'}, "No duplicate images found.")
            return {'FINISHED'}

        # 2. 遍历所有材质，替换节点中的引用
        for mat in bpy.data.materials:
            if not mat.use_nodes or not mat.node_tree: continue
            
            for node in mat.node_tree.nodes:
                if node.type == 'TEX_IMAGE' and node.image:
                    if node.image.name in remap_dict:
                        target_img = remap_dict[node.image.name]
                        print(f"Swapping {node.image.name} -> {target_img.name} in material {mat.name}")
                        node.image = target_img
                        cleaned_count += 1
                        
        # 3. 清理未使用的图片 (可选：purge)
        # 这里为了安全，只替换引用，不做 purge，用户可以手动 File -> Clean Up -> Unused Data Blocks
        
        # 刷新列表
        bpy.ops.tot.updateimagelist()
        
        self.report({'INFO'}, f"Replaced {cleaned_count} duplicate image references.")
        return {'FINISHED'}

class TOT_OT_DeleteTextureFolder(bpy.types.Operator):
    """删除指定的贴图文件夹 (物理删除)"""
    bl_idname = "tot.delete_texture_folder"
    bl_label = "Delete Folder"
    bl_options = {'REGISTER', 'UNDO'} # 注意：文件删除无法通过 Blender 的 Undo 撤销

    folder_name: bpy.props.StringProperty() # 接收参数

    def execute(self, context):
        base_path = bpy.path.abspath("//")
        if not base_path: return {'CANCELLED'}
        
        target_path = os.path.join(base_path, self.folder_name)
        
        if os.path.exists(target_path):
            try:
                # 危险操作：删除整个文件夹树
                shutil.rmtree(target_path)
                self.report({'INFO'}, f"Deleted folder: {self.folder_name}")
                
                # 强制刷新 UI
                context.area.tag_redraw()
            except Exception as e:
                self.report({'ERROR'}, f"Failed to delete: {e}")
                return {'CANCELLED'}
        else:
            self.report({'WARNING'}, "Folder not found.")
            
        return {'FINISHED'}

    def invoke(self, context, event):
        # 弹窗确认，防止误删
        return context.window_manager.invoke_confirm(self, event)

class TOT_OT_SwitchResolution(bpy.types.Operator):
    """在原图和不同分辨率的缓存图之间切换"""
    bl_idname = "tot.switch_resolution"
    bl_label = "Switch Texture Resolution"
    bl_options = {'REGISTER', 'UNDO'}

    # 接收目标分辨率参数，'ORIGINAL' 代表原图
    target_res: bpy.props.StringProperty() 

    def execute(self, context):
        scn = context.scene.tot_props
        target = self.target_res
        
        # 获取当前 blend 文件的绝对目录 (e.g. C:\Project\)
        base_path = bpy.path.abspath("//")
        if not base_path:
            self.report({'ERROR'}, "Save file first!")
            return {'CANCELLED'}

        switched_count = 0
        
        for item in scn.image_list:
            img = bpy.data.images.get(item.tot_image_name)
            if not img: continue
            if img.source in {'VIEWER', 'GENERATED'}: continue
            
            # --- 情况 A: 切换回原图 ---
            if target == 'ORIGINAL':
                # 只有当图片有“存档记录”时才能恢复
                if "tot_original_path" in img:
                    orig_path = img["tot_original_path"]
                    
                    # 检查文件是否还在
                    # 注意：存档的路径通常是相对路径 (//Texture/abc.jpg)，需要转绝对路径检查
                    abs_orig_path = bpy.path.abspath(orig_path)
                    
                    if os.path.exists(abs_orig_path):
                        img.filepath = orig_path
                        img.reload()
                        switched_count += 1
                    else:
                        print(f"[TOT] Original file missing: {abs_orig_path}")
                else:
                    # 没有存档，说明它本身就是原图，或者从未被本插件处理过
                    pass

            # --- 情况 B: 切换到指定分辨率 (如 1024) ---
            else:
                # ... (前面获取 clean_name_base 的逻辑不变) ...

                # 构造目标文件夹路径
                # [修改点]：如果 target 是 "camera_optimized"，不做 px 拼接
                if target == "camera_optimized":
                    folder_name = "textures_camera_optimized"
                else:
                    folder_name = f"textures_{target}px"
                
                target_dir_abs = os.path.join(base_path, folder_name)
                
                # 因为 optimized 文件夹里，Wood 可能是 Wood_512px.jpg，也可能是 Wood_2048px.jpg
                # 我们不能简单拼写文件名，我们需要去文件夹里“找”对应的前缀文件
                
                found_file = None
                
                if os.path.exists(target_dir_abs):
                    # 遍历该文件夹下的所有文件，寻找匹配 clean_name_base 的文件
                    # 比如 clean_name_base 是 "Wood"，我们要找 "Wood_xxxpx.jpg"
                    for f in os.listdir(target_dir_abs):
                        if f.startswith(clean_name_base):
                            # 简单的匹配：文件名包含 base name
                            # 严谨一点：f 必须是 Base + "_" + 数字 + "px" + ext
                            if clean_name_base in f:
                                found_file = f
                                break 
                
                if found_file:
                    target_fullpath_abs = os.path.join(target_dir_abs, found_file)
                    
                    rel_path = f"//{folder_name}/{found_file}"
                    img.filepath = rel_path
                    img.reload()
                    switched_count += 1
                else:
                    # 没找到对应文件（可能是因为该图片在优化时被判断为不可见，所以没生成）
                    pass
        
        # 刷新列表 UI
        bpy.ops.tot.updateimagelist()
        
        msg = f"Restored {switched_count} images to Original." if target == 'ORIGINAL' else f"Switched {switched_count} images to {target}px."
        self.report({'INFO'}, msg)
        return {'FINISHED'}
    
class TOT_OT_OptimizeByCamera(bpy.types.Operator):
    """【非阻塞版】根据相机视角自动计算并生成优化贴图"""
    bl_idname = "tot.optimize_by_camera"
    bl_label = "Optimize by Camera (Async)"
    bl_options = {'REGISTER', 'UNDO'}

    _timer = None
    _queue = []       # 待处理任务队列
    _processed = 0    # 已处理数量
    _total_tasks = 0  # 总任务数
    _output_dir = ""  # 输出路径
    
    # 状态变量
    _phase = 'INIT'   # INIT -> ANALYZING -> PROCESSING -> FINISHED

    TIME_BUDGET = 0.1

    def modal(self, context, event):
        if event.type == 'TIMER':
            # --- 阶段 1: 分析阶段 ---
            if self._phase == 'ANALYZING':
                self.do_analysis(context)
                self._phase = 'PROCESSING'
                context.window_manager.progress_begin(0, self._total_tasks)
                return {'RUNNING_MODAL'}

            # --- 阶段 2: 动态批处理阶段 ---
            elif self._phase == 'PROCESSING':
                
                # 记录这一帧开始的时间
                start_time = time.time()
                
                # 【核心循环】只要队列不为空，且没超时，就一直干活！
                while self._queue:
                    # 1. 取出任务
                    task_data = self._queue.pop(0)
                    self.process_image_task(task_data)
                    self._processed += 1
                    
                    # 2. 检查时间是否用完
                    # 如果当前操作耗时已经超过了 TIME_BUDGET (比如 0.1秒)
                    # 立即中断循环，把控制权还给 Blender 去刷新 UI
                    if (time.time() - start_time) > self.TIME_BUDGET:
                        break
                
                # 更新进度条 (不管处理了多少张，这一帧结束时更新一次)
                context.window_manager.progress_update(self._processed)
                
                # 如果队列空了，说明做完了
                if not self._queue:
                    self._phase = 'FINISHED'
            
            # --- 阶段 3: 结束 ---
            elif self._phase == 'FINISHED':
                self.finish(context)
                return {'FINISHED'}

        return {'PASS_THROUGH'}

    def invoke(self, context, event):
        scn = context.scene.tot_props
        cam = scn.lod_camera or context.scene.camera
        
        if not cam:
            self.report({'ERROR'}, "No active camera found!")
            return {'CANCELLED'}

        base_path = bpy.path.abspath("//")
        if not base_path:
            self.report({'ERROR'}, "Save file first!")
            return {'CANCELLED'}

        # 启动定时器，每 0.01 秒触发一次 modal
        wm = context.window_manager
        self._timer = wm.event_timer_add(0.01, window=context.window)
        wm.modal_handler_add(self)
        
        # 初始化状态
        self._phase = 'ANALYZING'
        self._queue = []
        self._processed = 0
        self._output_dir = os.path.join(base_path, "textures_camera_optimized")
        if not os.path.exists(self._output_dir):
            os.makedirs(self._output_dir)
            
        self.report({'INFO'}, "Starting Camera Optimization...")
        return {'RUNNING_MODAL'}

    def do_analysis(self, context):
        """分析场景，构建任务队列"""
        scn = context.scene.tot_props
        cam = scn.lod_camera or context.scene.camera
        
        # 1. 获取下限
        if scn.resize_size == 'c':
            min_user_floor = scn.custom_resize_size
        else:
            try: min_user_floor = int(scn.resize_size)
            except: min_user_floor = 64
        
        image_res_map = {}
        mesh_objs = [o for o in context.scene.objects if o.type == 'MESH' and not o.hide_render]
        
        # 这一步纯数学计算，通常很快，如果物体数过万才需要拆分
        for obj in mesh_objs:
            px_size, visible = utils.calculate_screen_coverage(context.scene, obj, cam)
            if not visible: continue 
            
            # 基础需求 + 下限保护
            calculated_res = px_size * 1.2 
            target_res = max(calculated_res, min_user_floor)
            
            for slot in obj.material_slots:
                if slot.material and slot.material.use_nodes:
                    for node in slot.material.node_tree.nodes:
                        if node.type == 'TEX_IMAGE' and node.image:
                            img = node.image
                            if img.source in {'VIEWER', 'GENERATED'}: continue
                            current_max = image_res_map.get(img, 0)
                            if target_res > current_max:
                                image_res_map[img] = target_res
        
        # 将 Map 转换为任务列表
        for img, req_px in image_res_map.items():
            self._queue.append((img, req_px))
            
        self._total_tasks = len(self._queue)
        print(f"[TOT] Analysis complete. {self._total_tasks} textures to process.")

    def process_image_task(self, task_data):
        """处理单张图片的逻辑"""
        img, req_px = task_data
        
        # 1. 计算最终尺寸
        final_size = 4
        if req_px <= 4: final_size = 4
        elif req_px <= 8: final_size = 8        
        if req_px <= 16: final_size = 16
        elif req_px <= 32: final_size = 32
        elif req_px <= 64: final_size = 64
        elif req_px <= 128: final_size = 128
        elif req_px <= 256: final_size = 256
        elif req_px <= 512: final_size = 512
        elif req_px <= 1024: final_size = 1024
        elif req_px <= 2048: final_size = 2048
        else: final_size = 4096
        
        # 限制不超过原图
        orig_w = img.size[0]
        orig_h = img.size[1]
        max_orig = max(orig_w, orig_h)
        if final_size > max_orig: final_size = max_orig
        if final_size < 4: final_size = 4

        try:
            # 构造路径
            if "tot_original_path" not in img:
                img["tot_original_path"] = img.filepath

            original_filepath = img.filepath_from_user()
            file_name = os.path.basename(original_filepath)
            if not file_name: file_name = f"{img.name}.png"
            name_part, ext_part = os.path.splitext(file_name)
            if not ext_part: ext_part = ".png"

            new_file_name = f"{name_part}_{final_size}px{ext_part}"
            new_full_path = os.path.join(self._output_dir, new_file_name)

            # --- [关键优化] 智能缓存检查 ---
            # 如果文件已经存在，且我们认为无需覆盖，则直接使用，跳过 scale 和 save
            file_exists = os.path.exists(new_full_path)
            
            if file_exists:
                # 只有当文件存在，我们直接重连，不进行 scale 和 I/O 操作
                # 这会极大地消除“重复运行”时的卡顿
                img.filepath = new_full_path
                img.reload()
                # print(f"Skipped (Cached): {new_file_name}")
            else:
                # 文件不存在，必须生成
                # Scale 和 Save 是最耗时的，这步在 Modal 里执行，不会卡死 UI
                img.scale(final_size, final_size)
                img.save_render(filepath=new_full_path)
                img.filepath = new_full_path
                img.reload()

        except Exception as e:
            print(f"Error processing {img.name}: {e}")

    def finish(self, context):
        """结束清理"""
        context.window_manager.event_timer_remove(self._timer)
        context.window_manager.progress_end()
        
        bpy.ops.tot.updateimagelist()
        
        # 强制刷新 UI
        for area in context.screen.areas:
            area.tag_redraw()
            
        self.report({'INFO'}, f"Camera Optimization Complete! Processed {self._processed} textures.")

    def cancel(self, context):
        context.window_manager.event_timer_remove(self._timer)
        context.window_manager.progress_end()

classes = (
    TOT_OT_UpdateImageList,
    TOT_OT_SelectAllImages,
    TOT_OT_ResizeImages,
    TOT_OT_ClearDuplicateImage,
    TOT_OT_DeleteTextureFolder,
    TOT_OT_SwitchResolution,
    TOT_OT_OptimizeByCamera,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\viewport.py
==================================================

import bpy
from mathutils import Vector

class TOT_OT_ViewportLODUpdate(bpy.types.Operator):
    """根据距离更新视窗显示模式 (Solid/Wire/Bounds)"""
    bl_idname = "tot.viewport_lod_update"
    bl_label = "Update Viewport LOD"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        if not scn.view_lod_enabled:
            self.report({'WARNING'}, "Viewport LOD is disabled in settings.")
            return {'CANCELLED'}

        # 1. 确定相机
        cam = scn.lod_camera or context.scene.camera
        if not cam:
            self.report({'ERROR'}, "No Camera found for LOD calculation.")
            return {'CANCELLED'}
        
        cam_loc = cam.matrix_world.translation
        d0, d1, d2 = scn.lod_dist_0, scn.lod_dist_1, scn.lod_dist_2
        
        count = 0
        
        # 3. 遍历场景物体
        for obj in context.scene.objects:
            if obj.type not in {'MESH', 'CURVE', 'SURFACE', 'META', 'FONT'}:
                continue

            # --- [核心修改] 第一次运行时，保存原始状态 ---
            # 我们使用自定义属性 (Custom Properties) 存储，不会影响渲染，且随文件保存
            if "_tot_orig_display" not in obj:
                obj["_tot_orig_display"] = obj.display_type
            
            if "_tot_orig_hide" not in obj:
                # 记录原始的隐藏状态 (注意：int 0/1 转换)
                obj["_tot_orig_hide"] = int(obj.hide_viewport)
            # -----------------------------------------------

            # 计算距离
            try:
                bbox_world = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]
                center = sum(bbox_world, Vector()) / 8.0
            except:
                center = obj.matrix_world.translation
            
            dist = (center - cam_loc).length
            
            # 判定 Level
            level = 0
            if dist <= d0: level = 0
            elif dist <= d1: level = 1
            elif dist <= d2: level = 2
            else: level = 3
            
            # 获取设置并应用
            attr_name = f"view_lod{level}_display"
            display_type = getattr(scn, attr_name, 'BOUNDS')
            should_hide = (level == 3 and scn.view_lod3_hide)
            
            obj.display_type = display_type
            obj.hide_viewport = should_hide
            
            count += 1
            
        self.report({'INFO'}, f"Viewport LOD Updated: {count} objects processed.")
        return {'FINISHED'}

class TOT_OT_ViewportLODReset(bpy.types.Operator):
    """恢复物体原本的显示模式"""
    bl_idname = "tot.viewport_lod_reset"
    bl_label = "Reset Viewport"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        restored_count = 0
        default_count = 0
        
        for obj in context.scene.objects:
            # 只处理几何体
            if obj.type not in {'MESH', 'CURVE', 'SURFACE', 'META', 'FONT'}:
                continue
                
            # --- [核心修改] 优先尝试从快照恢复 ---
            if "_tot_orig_display" in obj:
                # 恢复显示模式 (SOLID, WIRE, etc.)
                # 有时候保存的是 int，有时候是 str，根据 blender 版本稍微容错一下
                try:
                    obj.display_type = obj["_tot_orig_display"]
                except:
                    # 万一出错，回退到 Textured
                    obj.display_type = 'TEXTURED'
                
                # 恢复完成，删除快照，以便下次重新Update时记录新状态
                del obj["_tot_orig_display"]
                restored_count += 1
            else:
                # 如果没有快照 (比如手动操作过的物体)，默认回退到 Textured
                obj.display_type = 'TEXTURED'
                default_count += 1
            
            if "_tot_orig_hide" in obj:
                # 恢复隐藏状态
                obj.hide_viewport = bool(obj["_tot_orig_hide"])
                del obj["_tot_orig_hide"]
            else:
                # 默认显示
                obj.hide_viewport = False
            # ---------------------------------------
        
        msg = f"Reset: Restored {restored_count} objects to original state"
        if default_count > 0:
            msg += f", reset {default_count} to default."
            
        self.report({'INFO'}, msg)
        return {'FINISHED'}

classes = (
    TOT_OT_ViewportLODUpdate,
    TOT_OT_ViewportLODReset,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\__init__.py
==================================================

from . import analyzer
from . import image
from . import viewport  # 新增
from . import geometry  # 新增
import bpy

# --- 定义宏 Operator：一键执行所有优化 ---
class TOT_OT_RunAllOptimization(bpy.types.Operator):
    """依次运行所有启用的优化流程 (Texture, Geo, Viewport)"""
    bl_idname = "tot.run_all_optimization"
    bl_label = "Run All Optimizations"
    
    def execute(self, context):
        scn = context.scene.tot_props
        
        # 1. Viewport
        if scn.view_lod_enabled:
            bpy.ops.tot.viewport_lod_update()
            
        # 2. Geometry
        if scn.geo_lod_enabled:
            # 自动 Setup (如果还没加修改器)
            bpy.ops.tot.geo_lod_setup()
            # 更新参数
            bpy.ops.tot.geo_lod_update()
            
        # 3. Texture (未来扩展：这里可以加基于距离的贴图缩放逻辑)
        # currently mostly manual in the other panel
        
        self.report({'INFO'}, "All optimizations updated based on camera distance.")
        return {'FINISHED'}

def register():
    bpy.utils.register_class(TOT_OT_RunAllOptimization)

def unregister():
    bpy.utils.unregister_class(TOT_OT_RunAllOptimization)

==================================================
File Path: .\ui\lists.py
==================================================

import bpy

class TOT_UL_ImageStats(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        # 绘制列表的每一行
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            row = layout.row()
            
            # 选择框
            row.prop(item, "image_selected", text="")
            
            # 图片名
            split = row.split(factor=0.6)
            split.label(text=item.tot_image_name, icon='IMAGE_DATA')
            
            # 状态图标 (打包/链接)
            r = split.row()
            if item.packed_img == 1:
                r.label(text="", icon='PACKAGE')
            elif item.packed_img == 2:
                r.label(text="", icon='LINKED')
            
            # 大小
            r.label(text=f"{item.image_size} MB")

        elif self.layout_type == 'GRID':
            layout.alignment = 'CENTER'
            layout.label(text="", icon='IMAGE_DATA')

def register():
    bpy.utils.register_class(TOT_UL_ImageStats)

def unregister():
    bpy.utils.unregister_class(TOT_UL_ImageStats)

==================================================
File Path: .\ui\main_panels.py
==================================================

import bpy
import os
from ..i18n import tr
from .. import AUTHOR_NAME

class TOT_PT_MainPanel:
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Optimize" 
    bl_options = {'DEFAULT_CLOSED'}
#0. 顶部 Header与语言切换 面板
class TOT_PT_Header(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "" # 不显示默认标题，我们自己画
    bl_idname = "TOT_PT_Header"
    bl_order = 0  # 排序第一
    bl_options = {'HIDE_HEADER'} # 隐藏折叠箭头，看起来像纯 UI 栏

    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props

        # 创建一行
        row = layout.row(align=True)
        row.scale_y = 1.2 # 稍微高一点
        
        # 左侧：插件标题
        # 根据语言切换标题
        title = "Optimize Tools" if scn.language == 'EN' else "Blender 优化工具"
        row.label(text=title, icon='MODIFIER')

        sub = row.row()
        sub.scale_x = 0.8 # 让字体或者间距稍微紧凑一点，视情况调整
        sub.alignment = 'RIGHT' # 靠右对齐一点，或者紧跟标题
        
        # 这里的 icon 可以选 'URL', 'WORLD', 'COMMUNITY', 'User' 等
        # text 显示你的名字
        op = row.operator("tot.open_website", text=AUTHOR_NAME, icon='COMMUNITY', emboss=False)
        
        # 右侧：语言切换按钮 (expand=True 会把 Enum 显示为按钮组)
        row.prop(scn, "language", expand=True)
        
        layout.separator()

# 1. 集合分析器 (Collection Analyzer)
class TOT_PT_CollectionAnalyzer(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "1. Collection Analyzer"
    bl_idname = "TOT_PT_CollectionAnalyzer"
    bl_order = 1 # 排序权重

    #动态修改面板标题
    def draw_header(self, context):
        self.layout.label(text=tr("Collection Analyzer"))

    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        
        layout.prop(scn, "colA_Method", text=tr("Method"))
        
        # 如果是高级模式，显示颜色阈值
        if scn.colA_Method == 'm2':
            box = layout.box()
            box.label(text="Color Thresholds (Vertex %):", icon='PREFERENCES')
            
            col = box.column(align=True)
            r = col.row(); r.label(text="", icon='COLLECTION_COLOR_01'); r.prop(scn, "mult_veryhigh", slider=True)
            r = col.row(); r.label(text="", icon='COLLECTION_COLOR_02'); r.prop(scn, "mult_high", slider=True)
            r = col.row(); r.label(text="", icon='COLLECTION_COLOR_03'); r.prop(scn, "mult_medium", slider=True)
            r = col.row(); r.label(text="", icon='COLLECTION_COLOR_04'); r.prop(scn, "mult_low", slider=True)
            r = col.row(); r.label(text="", icon='COLLECTION_COLOR_05'); r.prop(scn, "mult_very_low", slider=True)

        layout.separator()
        row = layout.row(align=True)
        row.scale_y = 1.2
        
        # Toggle 按钮逻辑
        if not scn.CA_Toggle:
            row.operator("tot.collectionanalyzer", text="Run Analyzer", icon='PLAY')
        else:
            row.operator("tot.cleancolors", text="Clear Analyzer", icon='X')
            row.operator("tot.collectionanalyzer", text="", icon='FILE_REFRESH') # 刷新按钮

# 2. 视图分析器 (View Analyzer)
class TOT_PT_ViewAnalyzer(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "2. View Analyzer"
    bl_idname = "TOT_PT_ViewAnalyzer"
    bl_order = 2

    def draw_header(self, context):
        self.layout.label(text=tr("View Analyzer"))
        
    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        
        layout.label(text=tr("View Analyzer"), icon='SCENE_DATA')
        
        row = layout.row(align=True)
        row.scale_y = 1.2
        if not scn.AA_Toggle:
            row.operator("tot.viewanalyzer", text=tr("Run Analyzer"), icon='PLAY')
        else:
            row.operator("tot.cleanviewanalyzer", text=tr("Clear Analyzer"), icon='X')

# 3. 贴图列表与缩放 (Image Resizer)
class TOT_PT_ImageResizer(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "3. Image Resizer"
    bl_idname = "TOT_PT_ImageResizer"
    bl_order = 3

    def draw_header(self, context):
        self.layout.label(text=tr("Image Resizer"))

    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        
        # 扫描按钮
        row = layout.row()
        row.scale_y = 1.2
        row.operator("tot.updateimagelist", text=tr("Scan / Refresh Images"), icon='FILE_REFRESH')
        
        # 统计信息
        if scn.r_total_images > 0:
            box = layout.box()
            r = box.row()
            r.label(text=f"{tr('Total')}: {scn.r_total_images}")
            r.label(text=f"{tr('Mem')}: {scn.total_image_memory} MB")
        
        # 列表
        layout.template_list("TOT_UL_ImageStats", "", scn, "image_list", scn, "custom_index_image_list", rows=5)
        
        # 选择工具
        row = layout.row(align=True)
        row.operator("tot.imglistselectall", text=tr("Select All/None"), icon='CHECKBOX_HLT')
        
        layout.separator()
        layout.label(text="Resize Options:", icon='TOOL_SETTINGS')
        
        # 缩放选项
        col = layout.column(align=True)
        col.prop(scn, "resize_size", text=tr("Target"))
        if scn.resize_size == 'c':
            col.prop(scn, "custom_resize_size", text=tr("Pixels"))
            
        col.prop(scn, "duplicate_images", text=tr("Safe Mode (Copy Files)"))
        if scn.duplicate_images and not scn.use_same_directory:
             col.prop(scn, "custom_output_path", text=tr("Output"))
             
        # 执行缩放
        row = layout.row()
        row.scale_y = 1.4
        row.operator("tot.resizeimages", text=tr("Resize Selected Images"), icon='IMAGE_DATA')

        layout.separator()
        box_cam = layout.box()
        box_cam.label(text=tr("AI / Camera Optimization"), icon='VIEW_CAMERA')
        col = box_cam.column(align=True)
        col.label(text=tr("Auto-calculate size based on screen coverage"), icon='INFO')
        # 按钮
        col.operator("tot.optimize_by_camera", text=tr("Run Camera Optimization"), icon='SHADING_RENDERED')

        # 分辨率切换器 (Texture Switcher) ---
        layout.separator()
        box = layout.box()
        box.label(text=tr("Texture Switcher (Global)"), icon='UV_SYNC_SELECT')
        
        # 只有在保存文件后才能从文件夹加载
        row = box.row(align=True)
        row.scale_y = 1.2
        
        # 1. 原图按钮
        op = row.operator("tot.switch_resolution", text=tr("Original"), icon='FILE_IMAGE')
        op.target_res = "ORIGINAL"
        
        # 2. 动态检测已生成的文件夹，并生成对应的切换按钮
        # 这样如果没有生成 512px 的，就不显示 512 的按钮，或者你可以硬编码常用的
        base_path = bpy.path.abspath("//")
        # 2.1 检测 Camera Optimized 文件夹并显示按钮
        if base_path and os.path.exists(os.path.join(base_path, "textures_camera_optimized")):
            op = row.operator("tot.switch_resolution", text=tr("Auto-Opt"), icon='CAMERA_DATA')
            op.target_res = "camera_optimized" # 传给 Operator 的特殊字符串

        found_resolutions = []
        if base_path and os.path.exists(base_path):
            try:
                for item in os.listdir(base_path):
                    if os.path.isdir(os.path.join(base_path, item)) and item.startswith("textures_") and item.endswith("px"):
                        # 解析 "textures_1024px" -> "1024"
                        res_str = item.replace("textures_", "").replace("px", "")
                        if res_str.isdigit():
                            found_resolutions.append(res_str)
            except: pass
            
        found_resolutions.sort(key=int) # 按数字大小排序
        
        if found_resolutions:
            for res in found_resolutions:
                op = row.operator("tot.switch_resolution", text=f"{res}px")
                op.target_res = res
        else:
            row.label(text="(No resized sets found)")

# 4. LOD层级管理 (LOD Manager)
class TOT_PT_LODManager(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "4. LOD Manager"
    bl_idname = "TOT_PT_LODManager"
    bl_order = 4

    def draw_header(self, context):
        self.layout.label(text=tr("LOD Manager"))

    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        
        # ==========================================================
        # Part A: 基础设置 (相机 & 距离阈值)
        # ==========================================================
        layout.prop(scn, "lod_camera", icon='CAMERA_DATA')
        
        layout.separator()
        
        # 恢复距离设置 (专门供 Viewport 使用)
        # 使用 align=True 让它们排成紧凑的一行或一列
        col = layout.column(align=True)
        col.label(text=tr("LOD Distance Levels (For Viewport):"), icon='DRIVER_DISTANCE')
        
        row = col.row(align=True)
        row.prop(scn, "lod_dist_0", text=tr("High <"))
        row.prop(scn, "lod_dist_1", text=tr("Mid <"))
        row.prop(scn, "lod_dist_2", text=tr("Low <"))
        # 超过 lod_dist_2 的即为 Far
        
        layout.separator()

        # ==========================================================
        # Part B: 视窗显示优化 (Viewport Optimization)
        # 依赖上面的距离设置
        # ==========================================================
        box = layout.box()
        header = box.row()
        header.prop(scn, "view_lod_enabled", text=tr("Viewport Optimization"), icon='VIEW3D', toggle=True)
        
        if scn.view_lod_enabled:
            col = box.column(align=True)
            
            # 使用 split 让标签和选项对齐更好看
            def draw_lod_row(layout, label, prop_name):
                row = layout.row(align=True)
                row.label(text=label)
                row.prop(scn, prop_name, text="")
            
            draw_lod_row(col, f"0m - {scn.lod_dist_0}m (High):", "view_lod0_display")
            draw_lod_row(col, f"{scn.lod_dist_0}m - {scn.lod_dist_1}m (Mid):", "view_lod1_display")
            draw_lod_row(col, f"{scn.lod_dist_1}m - {scn.lod_dist_2}m (Low):", "view_lod2_display")
            draw_lod_row(col, f"> {scn.lod_dist_2}m (Far):", "view_lod3_display")
            
            col.separator()
            col.prop(scn, "view_lod3_hide", text=tr("Hide Far Objects"))
            
            # 操作按钮
            r = box.row(align=True)
            r.scale_y = 1.2
            r.operator("tot.viewport_lod_update", text=tr("Update View"), icon='FILE_REFRESH')
            r.operator("tot.viewport_lod_reset", text=tr("Reset"), icon='X')

        # ==========================================================
        # Part C: 模型几何优化 (Geometry LOD - Screen Coverage)
        # ==========================================================
        layout.separator()
        box = layout.box()
        
        # 头部
        row = box.row()
        row.label(text=tr("Geometry LOD (Screen Ratio)"), icon="MOD_DECIM")
        row.prop(scn, "geo_lod_enabled", text=tr("Enable"), toggle=True)
        
        if scn.geo_lod_enabled:
            # 1. 方法选择
            row = box.row(align=True)
            row.prop(scn, "geo_lod_method", text=tr("Method"))
            
            # 2. 参数显示
            col = box.column(align=True)
            col.prop(scn, "geo_lod_min_faces", text=tr("Min Faces (Safety)"))
            
            # 动态显示强度标签
            if scn.geo_lod_method == 'DECIMATE':
                # 注意：i18n字典里要加上对应的key
                col.prop(scn, "geo_lod_min_ratio", text=tr("Min Ratio (Safety Floor)"), slider=True)
                col.label(text=tr("Prevents breaking close-up details"), icon='INFO')
            else:
                col.prop(scn, "geo_lod_min_ratio", text=tr("GN Strength Factor"), slider=True)
                col.label(text=tr("Higher Strength = More Merging"), icon='INFO')

                row = col.row(align=True)
                row.prop(scn, "geo_lod_angle_threshold", text=tr("Edge Threshold")) # 这里的 text 需要翻译
                row.label(text="", icon='EDGESEL')

                row = col.row(align=True)
                row.prop(scn, "geo_lod_max_dist", text=tr("Max Merge Distance"))
                row.label(text="", icon='DRIVER_DISTANCE')
                
                col.label(text=tr("Higher Angle = More Merging"), icon='INFO')

            # 3. 三大核心按钮 (只保留这一个区域，删除原来的重复块)
            row = box.row(align=True)
            row.scale_y = 1.2
            row.operator("tot.geo_lod_setup", text=tr("Setup Modifiers"), icon="MODIFIER")
            
            # 使用 Async Update (防止卡顿)
            row.operator("tot.geo_lod_update_async", text=tr("Update Geometry (Async)"), icon="PLAY")
            
            row.operator("tot.geo_lod_reset", text=tr("Reset Geometry"), icon="FILE_REFRESH")   
            
            # 4. Apply 按钮
            row = box.row()
            row.scale_y = 1.2
            row.alert = True 
            op_text = tr("Apply Decimate (Destructive)") if scn.geo_lod_method == 'DECIMATE' else tr("Apply GeoNodes (Destructive)")
            row.operator("tot.geo_lod_apply", text=op_text, icon="CHECKMARK")
# 5. 去除重复贴图 (Duplicate Remover)
class TOT_PT_DuplicateRemover(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "5. Clean Up & Storage"
    bl_idname = "TOT_PT_DuplicateRemover"
    bl_order = 5
    
    def draw_header(self, context):
        self.layout.label(text=tr("Clean Up & Storage"))

    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        
        # ... (Data Cleanup 部分保持不变) ...
        box = layout.box()
        box.label(text=tr("Data Cleanup"), icon='BRUSH_DATA')
        col = box.column(align=True)
        col.operator("tot.clearduplicateimage", text=tr("Merge Duplicate Images (.001)"), icon='TRASH')

        # --- 外部文件夹管理 (修复版) ---
        box = layout.box()
        box.label(text=tr("Disk Storage Management"), icon='FILE_FOLDER')
        
        # 1. 获取绝对路径，并标准化路径分隔符
        raw_path = bpy.path.abspath("//")
        base_path = os.path.normpath(raw_path) if raw_path else None
        
        if not base_path or not os.path.exists(base_path):
            box.label(text=tr("Save file to see texture folders"), icon='ERROR')
        else:
            texture_folders = []
            try:
                # 扫描
                for item in os.listdir(base_path):
                    full_path = os.path.join(base_path, item)
                    # 必须是目录 且 名字匹配
                    if os.path.isdir(full_path) and item.startswith("textures_"):
                        texture_folders.append(item)
            except Exception as e:
                box.label(text=f"Scan Error: {str(e)}", icon='ERROR')
            
            if not texture_folders:
                box.label(text="No generated folders found.", icon='INFO')
            else:
                box.label(text=f"{tr('Found')} {len(texture_folders)} {tr('Texture Sets')}:", icon='FILE_IMAGE')
                
                for folder in texture_folders:
                    row = box.row()
                    row.alignment = 'EXPAND'
                    # 文件夹图标 + 名字
                    row.label(text=folder, icon='FOLDER_REDIRECT')
                    # 删除按钮
                    op = row.operator("tot.delete_texture_folder", text="", icon='X')
                    op.folder_name = folder

classes = (
    TOT_PT_Header,
    TOT_PT_CollectionAnalyzer,
    TOT_PT_ViewAnalyzer,
    TOT_PT_ImageResizer,
    TOT_PT_LODManager,
    TOT_PT_DuplicateRemover
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\ui\__init__.py
==================================================

from . import lists
from . import main_panels
