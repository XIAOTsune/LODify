
==================================================
File Path: .\merge.py
==================================================

import os

# 设置要生成的合并文件名
output_file = 'project_context.txt'

# 设置需要忽略的文件夹（例如 git 目录，编译目录等）
ignore_dirs = {'.git', 'node_modules', '__pycache__', 'dist', 'build', '.idea', '.vscode'}
# 设置需要读取的文件后缀（根据您的项目调整）
valid_extensions = {'.js', '.ts', '.vue', '.html', '.css', '.py', '.java', '.json', '.xml', '.go'}

with open(output_file, 'w', encoding='utf-8') as outfile:
    for root, dirs, files in os.walk('.'):
        # 过滤掉不需要的文件夹
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in files:
            if any(file.endswith(ext) for ext in valid_extensions):
                file_path = os.path.join(root, file)
                
                # 写入文件路径作为分隔符（这对 AI 理解结构至关重要）
                outfile.write(f"\n{'='*50}\n")
                outfile.write(f"File Path: {file_path}\n")
                outfile.write(f"{'='*50}\n\n")
                
                # 写入文件内容
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                        outfile.write("\n")
                except Exception as e:
                    outfile.write(f"Error reading file: {e}\n")

print(f"完成！所有代码已合并到 {output_file}，请将该文件上传给 Gemini。")

==================================================
File Path: .\properties.py
==================================================

import bpy
from bpy.props import (
    StringProperty, BoolProperty, IntProperty, FloatProperty, 
    EnumProperty, CollectionProperty, PointerProperty
)

# --- 数据项类 (Collection Items) ---
class TOT_ImageItem(bpy.types.PropertyGroup):
    tot_image_name: StringProperty()
    image_size: StringProperty()
    image_selected: BoolProperty(default=False)
    packed_img: IntProperty(default=0) # 0:File, 1:Packed, 2:Linked

# --- 主属性组 ---
class TOT_Props(bpy.types.PropertyGroup):
    # ==========================================================
    # 1. 全局开关与分析器
    # ==========================================================
    CA_Toggle: BoolProperty(default=False, name="Collection Analyzer Toggle")
    AA_Toggle: BoolProperty(default=False, name="Scene Analyzer Toggle")
    
    colA_Method: EnumProperty(
        name="Method", 
        items=[('m1', 'Default', ''), ('m2', 'Advanced', '')],
        default='m1'
    )
    # 分析器阈值
    mult_veryhigh: FloatProperty(default=0.9, min=0, max=1)
    mult_high: FloatProperty(default=0.8, min=0, max=1)
    mult_medium: FloatProperty(default=0.6, min=0, max=1)
    mult_low: FloatProperty(default=0.2, min=0, max=1)
    mult_very_low: FloatProperty(default=0.0, min=0, max=1)
    
    default_col_colors: StringProperty() 
    last_shading: StringProperty()

    # ==========================================================
    # 2. LOD 管理器核心设置 (LOD Manager Core)
    # ==========================================================
    # 用于计算距离的相机
    lod_camera: PointerProperty(
        name="LOD Camera",
        description="用于计算距离的相机，不设置则使用场景主相机",
        type=bpy.types.Object,
    )

    # 三个距离阈值 (定义 High / Mid / Low 区域)
    # Zone 1 (High): 0 ~ dist_0
    # Zone 2 (Mid):  dist_0 ~ dist_1
    # Zone 3 (Low):  dist_1 ~ dist_2
    # Zone 4 (Far):  > dist_2
    lod_dist_0: FloatProperty(name="Distance L0 (High)", default=10.0, min=0.0, unit='LENGTH')
    lod_dist_1: FloatProperty(name="Distance L1 (Mid)", default=30.0, min=0.0, unit='LENGTH')
    lod_dist_2: FloatProperty(name="Distance L2 (Low)", default=60.0, min=0.0, unit='LENGTH')

    # ==========================================================
    # 3. 维度三：视窗优化 (Viewport Optimization)
    # ==========================================================
    view_lod_enabled: BoolProperty(
        name="Enable Viewport LOD",
        description="根据距离改变物体显示模式 (Solid/Wire/Bounds)",
        default=False,
    )
    
    # 定义显示模式枚举
    display_items = (
        ('TEXTURED', "Textured", "完整材质"),
        ('SOLID',    "Solid",    "实体显示"),
        ('WIRE',     "Wire",     "线框显示"),
        ('BOUNDS',   "Bounds",   "包围盒 (最快)"),
    )

    view_lod0_display: EnumProperty(name="L0 Display", items=display_items, default='TEXTURED')
    view_lod1_display: EnumProperty(name="L1 Display", items=display_items, default='SOLID')
    view_lod2_display: EnumProperty(name="L2 Display", items=display_items, default='WIRE')
    view_lod3_display: EnumProperty(name="L3 Display", items=display_items, default='BOUNDS')
    
    view_lod3_hide: BoolProperty(name="Hide at L3", description="在极远距离直接隐藏物体", default=False)

    # ==========================================================
    # 4. 维度二：模型减面 (Geometry LOD)
    # ==========================================================
    geo_lod_enabled: BoolProperty(
        name="Enable Geometry LOD",
        description="启用基于距离的自动减面系统",
        default=False,
    )
    
    geo_lod_method: EnumProperty(
        name="LOD Method",
        items=[
            ("DECIMATE", "Decimate Modifier", "使用传统 Decimate 修改器 (破坏性较小，兼容性好)"),
            ("GNODES", "Geometry Nodes", "使用几何节点 (计算更快，功能更现代)"),
        ],
        default="DECIMATE",
    )
    
    geo_lod_min_faces: IntProperty(
        name="Min Faces", 
        default=1000, 
        min=0, 
        description="保护机制：面数少于此值的物体将不会被减面"
    )
    
    # 这个参数同时控制 Decimate 的 ratio 和 GN 的 Factor
    geo_lod_min_ratio: FloatProperty(
        name="Max Reduction Strength", 
        default=0.1, 
        min=0.01, 
        max=1.0, 
        description="最远距离时的压缩比例 (Decimate Ratio) 或 强度因子"
    )
    # ==========================================================
    # 5. 维度一：贴图管理 (Texture Management)
    # ==========================================================
    image_list: CollectionProperty(type=TOT_ImageItem)
    custom_index_image_list: IntProperty()
    
    image_data_method: EnumProperty(
        name="Source",
        items=[('s1', 'Blend Data', ''), ('s2', 'Original Files', '')],
        default='s1'
    )
    resize_size: EnumProperty(
        name="Target Size",
        items=[
            ('128', '128 px', ''), ('256', '256 px', ''), ('512', '512 px', ''),
            ('1024', '1024 px', ''), ('2048', '2048 px', ''), ('c', 'Custom', '')
        ],
        default='1024'
    )
    custom_resize_size: IntProperty(default=1024, min=4)
    use_same_directory: BoolProperty(default=True, name="Same Directory")
    custom_output_path: StringProperty(subtype='DIR_PATH')
    duplicate_images: BoolProperty(default=True, name="Duplicate Files")

    # 统计信息
    r_total_images: IntProperty()
    total_image_memory: StringProperty()

# 注册列表
classes = (
    TOT_ImageItem,
    TOT_Props,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Scene.tot_props = PointerProperty(type=TOT_Props)

def unregister():
    del bpy.types.Scene.tot_props
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\utils.py
==================================================

import bpy

def get_collection_vertex_count(collection):
    """递归计算集合内所有 Mesh 对象的顶点总数"""
    total_verts = 0
    # 遍历集合内的所有对象
    for obj in collection.all_objects:
        if obj.type == 'MESH' and obj.data:
            total_verts += len(obj.data.vertices)
    return total_verts

def get_image_size_str(image):
    """估算图片占用的内存大小 (MB)"""
    if not image:
        return "0.00"
    
    try:
        width = image.size[0]
        height = image.size[1]
        # 估算：宽 * 高 * 4通道 (RGBA) * 深度 (通常 32bit float 或 8bit byte)
        # 这里简化按未压缩的 RGBA 8bit 估算，或者 32bit float
        # Blender 内部通常是 32bit float (4 bytes per channel)
        bytes_size = width * height * 4 * 4 
        size_mb = bytes_size / (1024 * 1024)
        return f"{size_mb:.2f}"
    except:
        return "0.00"

def format_large_number(num):
    """将大数字格式化为 K/M 后缀"""
    if num >= 1000000:
        return f"{num/1000000:.1f}M"
    elif num >= 1000:
        return f"{num/1000:.1f}K"
    else:
        return str(num)

==================================================
File Path: .\__init__.py
==================================================

import bpy
from . import properties
from . import ui 
from . import operators

# --- 1. 兼容 Legacy Add-on (Blender < 4.2) ---
# 即使是 Extension 模式，保留这个也不会报错，旧版本则依赖它识别插件。
bl_info = {
    "name": "ToOptimize Tools (LOD Edition)",
    "author": "Your Name",
    "version": (1, 3, 0),
    "blender": (3, 6, 0), # 设置为你支持的最低版本
    "location": "View3D > Sidebar > Optimize",
    "description": "全场景性能优化：贴图、减面与视窗管理",
    "warning": "",
    "doc_url": "https://help.cgoutset.com/",
    "category": "3D View",
}

# 模块列表
modules = [
    properties,
    ui.lists,
    ui.main_panels,
    operators.analyzer,
    operators.image, 
    operators.viewport,
    operators.geometry,
    operators, 
]

def register():
    for mod in modules:
        try:
            mod.register()
        except Exception as e:
            # 打印错误但不要让插件加载完全失败，方便调试
            print(f"ToOptimize Register Error in {mod}: {e}")

def unregister():
    # --- 2. 安全卸载逻辑 ---
    # 卸载的关键是：即使出错也要继续执行，不能因为一个错误卡住整个卸载过程
    for mod in reversed(modules):
        try:
            mod.unregister()
        except Exception as e:
            print(f"ToOptimize Unregister Error in {mod}: {e}")
            pass # 强制继续卸载下一个模块

    # 清理可能残留的属性 (防止下次加载报错)
    if hasattr(bpy.types.Scene, "tot_props"):
        del bpy.types.Scene.tot_props

==================================================
File Path: .\operators\analyzer.py
==================================================

import bpy
from .. import utils

class TOT_OT_CollectionAnalyzer(bpy.types.Operator):
    """Run Collection Analyzer"""
    bl_idname = "tot.collectionanalyzer"
    bl_label = "Run Analyzer"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        # 1. 清理旧状态
        bpy.ops.tot.cleancolors()

        self.report({'INFO'}, "Analyzing Collections...")
        
        # 备份当前颜色状态，以便 Clear 时恢复
        backup = {}
        
        # 获取基础阈值 (假设基准是 100万面，你可以调整这个基数)
        BASE_COUNT = 1000000 
        
        # 遍历所有集合
        for col in bpy.data.collections:
            # 记录原始颜色
            backup[col.name] = col.color_tag
            
            # 计算该集合的顶点数
            v_count = utils.get_collection_vertex_count(col)
            
            # 逻辑判定：根据顶点数赋予颜色
            # COLOR_01: Red (Very High)
            # COLOR_02: Orange (High)
            # COLOR_03: Yellow (Medium)
            # COLOR_04: Green (Low)
            # COLOR_05: Blue (Very Low/Safe)
            
            if v_count > (BASE_COUNT * scn.mult_veryhigh): # 0.9
                col.color_tag = 'COLOR_01'
            elif v_count > (BASE_COUNT * scn.mult_high):   # 0.8
                col.color_tag = 'COLOR_02'
            elif v_count > (BASE_COUNT * scn.mult_medium): # 0.6
                col.color_tag = 'COLOR_03'
            elif v_count > (BASE_COUNT * scn.mult_low):    # 0.2
                col.color_tag = 'COLOR_04'
            else:
                col.color_tag = 'NONE' # 或者 'COLOR_05'

        # 保存备份数据到字符串属性中
        scn.default_col_colors = str(backup)
        
        # 更新 UI 状态
        scn.CA_Toggle = True 
        
        return {'FINISHED'}
    
class TOT_OT_CleanColors(bpy.types.Operator):
    """Clear Analysis Results"""
    bl_idname = "tot.cleancolors"
    bl_label = "Clear Analyzer"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        if scn.default_col_colors:
            try:
                data = eval(scn.default_col_colors)
                for col in bpy.data.collections:
                    # 只有当集合还在时才恢复
                    if col.name in data:
                        col.color_tag = data[col.name]
            except Exception as e:
                print(f"Restore Error: {e}")
        
        # 归零状态
        scn.CA_Toggle = False
        scn.default_col_colors = ""
        
        return {'FINISHED'}

# --- 3D View Analyzer (同理) ---
class TOT_OT_ViewAnalyzer(bpy.types.Operator):
    bl_idname = "tot.viewanalyzer"
    bl_label = "Run 3D View Analyzer"
    
    def execute(self, context):
        scn = context.scene.tot_props
        # 备份当前显示模式
        if context.space_data.type == 'VIEW_3D':
            scn.last_shading = context.space_data.shading.color_type
            # 切换为 Object Color 显示
            context.space_data.shading.type = 'SOLID'
            context.space_data.shading.color_type = 'OBJECT'
        
        # [核心修复]
        scn.AA_Toggle = True
        return {'FINISHED'}

class TOT_OT_CleanViewAnalyzer(bpy.types.Operator):
    bl_idname = "tot.cleanviewanalyzer"
    bl_label = "Clear View Analyzer"
    
    def execute(self, context):
        scn = context.scene.tot_props
        # 还原
        if context.space_data.type == 'VIEW_3D':
             # 防止出错，如果有备份则用备份，否则默认 MATERIAL
            target = scn.last_shading if scn.last_shading else 'MATERIAL'
            context.space_data.shading.color_type = target
        
        # [核心修复]
        scn.AA_Toggle = False
        return {'FINISHED'}

classes = (
    TOT_OT_CollectionAnalyzer,
    TOT_OT_CleanColors,
    TOT_OT_ViewAnalyzer,
    TOT_OT_CleanViewAnalyzer,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\geometry.py
==================================================

import bpy
from mathutils import Vector

# 定义常量
DECIMATE_MOD_NAME = "TOT_LOD_DECIMATE"
GEO_NODES_MOD_NAME = "TOT_GEO_LOD"
GN_INPUT_NAME = "LOD_Factor" # 几何节点中定义的输入名称

# --- Helper: 节点组逻辑 ---
def ensure_lod_node_group():
    """确保存在一个几何 LOD 节点组"""
    name = "TOT_GEO_LOD_Basic"
    group = bpy.data.node_groups.get(name)
    if not group:
        group = bpy.data.node_groups.new(name=name, type="GeometryNodeTree")
        
        # 兼容 Blender 4.0+ / 5.0 接口
        if hasattr(group, "interface"):
            group.interface.clear()
            group.interface.new_socket(name="Geometry", in_out='INPUT', socket_type='NodeSocketGeometry')
            # 这里的 name="LOD_Factor" 很重要
            sock_factor = group.interface.new_socket(name=GN_INPUT_NAME, in_out='INPUT', socket_type='NodeSocketFloat')
            sock_factor.min_value = 0.0
            sock_factor.max_value = 1.0
            sock_factor.default_value = 0.0
            group.interface.new_socket(name="Geometry", in_out='OUTPUT', socket_type='NodeSocketGeometry')
        
        nodes = group.nodes
        links = group.links
        nodes.clear()
        
        # --- 节点构建 ---
        input_node = nodes.new("NodeGroupInput")
        output_node = nodes.new("NodeGroupOutput")
        input_node.location = (-400, 0)
        output_node.location = (400, 0)
        
        # 1. BBox 对角线计算
        node_bbox = nodes.new("GeometryNodeBoundBox")
        node_bbox.location = (-200, 200)
        
        node_sub = nodes.new("ShaderNodeVectorMath")
        node_sub.operation = 'SUBTRACT'
        node_sub.location = (0, 200)
        
        node_len = nodes.new("ShaderNodeVectorMath")
        node_len.operation = 'LENGTH'
        node_len.location = (160, 200)
        
        # 2. 基准距离 (0.1 系数)
        node_math_base = nodes.new("ShaderNodeMath")
        node_math_base.operation = 'MULTIPLY'
        node_math_base.inputs[1].default_value = 0.1
        node_math_base.location = (320, 200)
        
        # 3. 核心控制：乘以 LOD_Factor
        node_math_final = nodes.new("ShaderNodeMath")
        node_math_final.operation = 'MULTIPLY'
        node_math_final.label = "Strength Control"
        node_math_final.location = (320, 0)
        
        # 4. Merge Node
        node_merge = nodes.new("GeometryNodeMergeByDistance")
        node_merge.location = (500, 0)
        
        # --- 连线 ---
        links.new(input_node.outputs["Geometry"], node_merge.inputs["Geometry"])
        links.new(input_node.outputs["Geometry"], node_bbox.inputs["Geometry"])
        
        links.new(node_bbox.outputs["Min"], node_sub.inputs[0])
        links.new(node_bbox.outputs["Max"], node_sub.inputs[1])
        links.new(node_sub.outputs["Vector"], node_len.inputs["Vector"])
        links.new(node_len.outputs["Value"], node_math_base.inputs[0])
        
        links.new(node_math_base.outputs["Value"], node_math_final.inputs[0])
        
        # 连接接口输入 (LOD_Factor) 到 Math Node
        # 注意：使用 Identifier 查找或者索引查找，这里用 Interface 对应的 output
        # 在 Group Input 节点上，outputs 的顺序对应 Interface 定义的 Inputs
        # 0: Geometry, 1: LOD_Factor
        links.new(input_node.outputs[1], node_math_final.inputs[1])
        
        links.new(node_math_final.outputs["Value"], node_merge.inputs["Distance"])
        links.new(node_merge.outputs["Geometry"], output_node.inputs["Geometry"])

    return group

def get_input_identifier(node_group, input_name):
    """
    [核心修复] 获取几何节点输入属性的真实 Identifier
    Blender 内部并不总是使用 Name 作为 Key，而是使用 Identifier (如 "Socket_2")
    """
    if not node_group:
        return None
        
    # Blender 4.0+ 使用 interface
    if hasattr(node_group, "interface"):
        for item in node_group.interface.items_tree:
            if item.item_type == 'SOCKET' and item.in_out == 'INPUT':
                if item.name == input_name:
                    return item.identifier
    # 旧版本兼容
    elif hasattr(node_group, "inputs"):
        for input_socket in node_group.inputs:
            if input_socket.name == input_name:
                return input_socket.identifier
                
    return None

# --- Operators ---

class TOT_OT_GeoLODSetup(bpy.types.Operator):
    """Setup Geometry LOD Modifiers"""
    bl_idname = "tot.geo_lod_setup"
    bl_label = "Setup Modifiers"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        method = scn.geo_lod_method
        min_faces = scn.geo_lod_min_faces
        
        created = 0
        lod_group = ensure_lod_node_group() if method == 'GNODES' else None
        
        for obj in context.scene.objects:
            if obj.type != 'MESH': continue
            if min_faces > 0 and len(obj.data.polygons) < min_faces: continue
            
            if method == 'DECIMATE':
                # 清理 GN
                if obj.modifiers.get(GEO_NODES_MOD_NAME):
                    obj.modifiers.remove(obj.modifiers.get(GEO_NODES_MOD_NAME))
                    
                mod = obj.modifiers.get(DECIMATE_MOD_NAME)
                if not mod:
                    mod = obj.modifiers.new(DECIMATE_MOD_NAME, 'DECIMATE')
                    mod.decimate_type = 'COLLAPSE'
                    mod.ratio = 1.0
                    obj["_tot_geo_lod_created"] = True
                    created += 1
                    
            elif method == 'GNODES':
                # 清理 Decimate
                if obj.modifiers.get(DECIMATE_MOD_NAME):
                    obj.modifiers.remove(obj.modifiers.get(DECIMATE_MOD_NAME))

                mod = obj.modifiers.get(GEO_NODES_MOD_NAME)
                if not mod:
                    mod = obj.modifiers.new(name=GEO_NODES_MOD_NAME, type='NODES')
                    mod.node_group = lod_group
                    obj["_tot_geo_lod_created"] = True
                    created += 1

        self.report({'INFO'}, f"Setup complete: {created} modifiers added.")
        return {'FINISHED'}

class TOT_OT_GeoLODUpdate(bpy.types.Operator):
    """Update Geometry based on Camera Distance"""
    bl_idname = "tot.geo_lod_update"
    bl_label = "Update Geometry"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        if not scn.geo_lod_enabled:
            self.report({'WARNING'}, "Geometry LOD is disabled.")
            return {'CANCELLED'}
        
        cam = scn.lod_camera or context.scene.camera
        if not cam: 
            self.report({'ERROR'}, "No Camera found.")
            return {'CANCELLED'}
        
        cam_loc = cam.matrix_world.translation
        d0, d1, d2 = scn.lod_dist_0, scn.lod_dist_1, scn.lod_dist_2
        method = scn.geo_lod_method
        strength = scn.geo_lod_min_ratio 
        
        updated = 0
        
        # 预查找 Identifier
        gn_identifier = None
        if method == 'GNODES':
            group = bpy.data.node_groups.get("TOT_GEO_LOD_Basic")
            gn_identifier = get_input_identifier(group, GN_INPUT_NAME)
            if not gn_identifier:
                ensure_lod_node_group()
                group = bpy.data.node_groups.get("TOT_GEO_LOD_Basic")
                gn_identifier = get_input_identifier(group, GN_INPUT_NAME)
        
        for obj in context.scene.objects:
            if obj.type != 'MESH': continue
            
            try:
                bbox_world = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]
                center = sum(bbox_world, Vector()) / 8.0
            except:
                center = obj.matrix_world.translation
            
            dist = (center - cam_loc).length
            
            # 4级判定
            if dist <= d0: level = 0
            elif dist <= d1: level = 1
            elif dist <= d2: level = 2
            else: level = 3
            
            factor = level / 3.0
            
            if method == 'DECIMATE':
                mod = obj.modifiers.get(DECIMATE_MOD_NAME)
                if mod:
                    target_ratio = 1.0 - factor * (1.0 - strength)
                    # 只有值真的变了才操作，节省资源
                    if abs(mod.ratio - target_ratio) > 0.0001:
                        mod.ratio = target_ratio
                        obj.update_tag() # 标记数据脏
                        updated += 1
            
            elif method == 'GNODES':
                mod = obj.modifiers.get(GEO_NODES_MOD_NAME)
                if mod and gn_identifier:
                    final_value = factor * strength
                    try:
                        current_val = mod.get(gn_identifier, -1.0)
                        if abs(current_val - final_value) > 0.0001:
                            mod[gn_identifier] = final_value
                            obj.update_tag(refresh={'DATA'}) # 标记几何脏
                            updated += 1
                    except:
                        pass
        

        # 1. 强制依赖图计算 (Data Level)
        context.view_layer.update()

        # 2. 强制窗口重绘 (UI/Pixel Level)
        # 遍历所有窗口的所有区域，找到 3D 视图并强制重绘
        for window in context.window_manager.windows:
            for area in window.screen.areas:
                if area.type == 'VIEW_3D':
                    area.tag_redraw()

        self.report({'INFO'}, f"Updated {updated} objects (Strength: {strength:.2f}).")
        return {'FINISHED'}

class TOT_OT_GeoLODReset(bpy.types.Operator):
    """Reset / Remove Modifiers"""
    bl_idname = "tot.geo_lod_reset"
    bl_label = "Reset Geometry"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        removed = 0
        for obj in context.scene.objects:
            mod_dec = obj.modifiers.get(DECIMATE_MOD_NAME)
            if mod_dec: 
                obj.modifiers.remove(mod_dec)
                removed += 1
                
            mod_gn = obj.modifiers.get(GEO_NODES_MOD_NAME)
            if mod_gn: 
                obj.modifiers.remove(mod_gn)
                removed += 1
            
            if "_tot_geo_lod_created" in obj:
                del obj["_tot_geo_lod_created"]

        self.report({'INFO'}, f"Reset complete. Cleaned {removed} objects.")
        return {'FINISHED'}

class TOT_OT_GeoLODApply(bpy.types.Operator):
    """Apply LOD Modifier"""
    bl_idname = "tot.geo_lod_apply"
    bl_label = "Apply (Destructive)"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        method = scn.geo_lod_method
        target_mod_name = DECIMATE_MOD_NAME if method == 'DECIMATE' else GEO_NODES_MOD_NAME
        
        if context.object and context.object.mode != 'OBJECT':
            bpy.ops.object.mode_set(mode='OBJECT')
            
        applied = 0
        targets = [o for o in context.scene.objects if o.type == 'MESH' and o.modifiers.get(target_mod_name)]
        
        if not targets:
            self.report({'WARNING'}, "No modifiers found to apply.")
            return {'CANCELLED'}

        active_old = context.view_layer.objects.active
        selected_old = context.selected_objects
        bpy.ops.object.select_all(action='DESELECT')
        
        for obj in targets:
            context.view_layer.objects.active = obj
            obj.select_set(True)
            try:
                bpy.ops.object.modifier_apply(modifier=target_mod_name)
                if "_tot_geo_lod_created" in obj:
                    del obj["_tot_geo_lod_created"]
                applied += 1
            except Exception as e:
                print(f"Apply failed on {obj.name}: {e}")
            obj.select_set(False)
            
        for o in selected_old:
            try: o.select_set(True)
            except: pass
        if active_old:
            context.view_layer.objects.active = active_old
            
        self.report({'INFO'}, f"Applied LOD to {applied} objects.")
        return {'FINISHED'}

classes = (
    TOT_OT_GeoLODSetup,
    TOT_OT_GeoLODUpdate,
    TOT_OT_GeoLODReset,
    TOT_OT_GeoLODApply,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\image.py
==================================================

import bpy
from .. import utils # 导入工具

class TOT_OT_UpdateImageList(bpy.types.Operator):
    bl_idname = "tot.updateimagelist"
    bl_label = "Update Image List"
    
    def execute(self, context):
        scn = context.scene.tot_props
        scn.image_list.clear()
        
        total_size_mb = 0.0
        count = 0
        
        for img in bpy.data.images:
            # 排除渲染结果和浏览器节点
            if img.name in {'Render Result', 'Viewer Node'}: continue
            # 排除生成的图片 (Generated) 通常不需要压缩
            if img.source == 'GENERATED': continue

            item = scn.image_list.add()
            item.tot_image_name = img.name
            
            # 状态检查
            if img.packed_file:
                item.packed_img = 1 # Packed
            elif img.library:
                item.packed_img = 2 # Linked
            else:
                item.packed_img = 0 # File
            
            # 计算大小
            size_str = utils.get_image_size_str(img)
            item.image_size = size_str
            total_size_mb += float(size_str)
            
            count += 1
            
        scn.r_total_images = count
        scn.total_image_memory = f"{total_size_mb:.2f}"
        
        return {'FINISHED'}

class TOT_OT_SelectAllImages(bpy.types.Operator):
    bl_idname = "tot.imglistselectall"
    bl_label = "Select All"
    
    def execute(self, context):
        scn = context.scene.tot_props
        # 智能反选
        has_unselected = any(not i.image_selected for i in scn.image_list)
        for i in scn.image_list:
            i.image_selected = has_unselected
        return {'FINISHED'}

class TOT_OT_ResizeImages(bpy.types.Operator):
    bl_idname = "tot.resizeimages"
    bl_label = "Resize Images"
    
    def execute(self, context):
        scn = context.scene.tot_props
        
        # 获取目标尺寸
        if scn.resize_size == 'c':
            target_size = scn.custom_resize_size
        else:
            target_size = int(scn.resize_size)

        resized_count = 0
        
        # 遍历 UI 列表
        for item in scn.image_list:
            if item.image_selected:
                img = bpy.data.images.get(item.tot_image_name)
                if not img: continue
                
                # 只有当图片大于目标尺寸时才缩小
                if img.size[0] > target_size or img.size[1] > target_size:
                    try:
                        # 缩放逻辑
                        img.scale(target_size, target_size)
                        
                        # !注意!：如果是外部文件，Blender 不会自动保存覆盖原图
                        # 如果是 Packed 图片，数据已经改变
                        
                        self.report({'INFO'}, f"Resized: {img.name}")
                        resized_count += 1
                    except Exception as e:
                        self.report({'ERROR'}, f"Failed to resize {img.name}: {e}")

        # 刷新列表显示最新大小
        bpy.ops.tot.updateimagelist()
        
        self.report({'INFO'}, f"Completed! Resized {resized_count} images.")
        return {'FINISHED'}

class TOT_OT_ClearDuplicateImage(bpy.types.Operator):
    bl_idname = "tot.clearduplicateimage"
    bl_label = "Clear Duplicate Images"

    def execute(self, context):
        # 简单的去重逻辑：如果名字是以 .001, .002 结尾，尝试查找无后缀的原名
        # 并替换用户的引用
        # 这里仅作占位，实际去重逻辑比较复杂，建议先保留空壳或简单打印
        self.report({'INFO'}, "Feature coming soon: Duplicate Cleaner")
        return {'FINISHED'}

classes = (
    TOT_OT_UpdateImageList,
    TOT_OT_SelectAllImages,
    TOT_OT_ResizeImages,
    TOT_OT_ClearDuplicateImage,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\viewport.py
==================================================

import bpy
from mathutils import Vector

class TOT_OT_ViewportLODUpdate(bpy.types.Operator):
    """根据距离更新视窗显示模式 (Solid/Wire/Bounds)"""
    bl_idname = "tot.viewport_lod_update"
    bl_label = "Update Viewport LOD"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        scn = context.scene.tot_props
        
        if not scn.view_lod_enabled:
            self.report({'WARNING'}, "Viewport LOD is disabled in settings.")
            return {'CANCELLED'}

        # 1. 确定相机
        cam = scn.lod_camera or context.scene.camera
        if not cam:
            self.report({'ERROR'}, "No Camera found for LOD calculation.")
            return {'CANCELLED'}
        
        cam_loc = cam.matrix_world.translation
        
        # 2. 获取阈值
        d0 = scn.lod_dist_0
        d1 = scn.lod_dist_1
        d2 = scn.lod_dist_2
        
        count = 0
        
        # 3. 遍历场景物体 (可以优化为只遍历选中的，或者指定集合)
        for obj in context.scene.objects:
            # 只处理几何体
            if obj.type not in {'MESH', 'CURVE', 'SURFACE', 'META', 'FONT'}:
                continue
                
            # 计算距离 (使用包围盒中心，比原点更准)
            try:
                # 简单计算：取包围盒8个点的平均值作为中心
                bbox_world = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]
                center = sum(bbox_world, Vector()) / 8.0
            except:
                center = obj.matrix_world.translation
            
            dist = (center - cam_loc).length
            
            # 4. 判定 Level
            level = 0
            if dist <= d0:
                level = 0
            elif dist <= d1:
                level = 1
            elif dist <= d2:
                level = 2
            else:
                level = 3
                
            # 5. 应用设置
            # 获取对应层级的显示设置属性名
            attr_name = f"view_lod{level}_display"
            display_type = getattr(scn, attr_name, 'BOUNDS')
            
            # 特殊处理：Level 3 是否隐藏
            should_hide = (level == 3 and scn.view_lod3_hide)
            
            # 写入状态
            obj.display_type = display_type
            obj.hide_viewport = should_hide
            
            count += 1
            
        self.report({'INFO'}, f"Viewport LOD Updated: {count} objects processed.")
        return {'FINISHED'}

class TOT_OT_ViewportLODReset(bpy.types.Operator):
    """重置所有物体为 Textured 显示"""
    bl_idname = "tot.viewport_lod_reset"
    bl_label = "Reset Viewport"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        for obj in context.scene.objects:
            if obj.type in {'MESH', 'CURVE', 'SURFACE', 'FONT'}:
                obj.display_type = 'TEXTURED'
                obj.hide_viewport = False
        
        self.report({'INFO'}, "Viewport display reset.")
        return {'FINISHED'}

classes = (
    TOT_OT_ViewportLODUpdate,
    TOT_OT_ViewportLODReset,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\operators\__init__.py
==================================================

from . import analyzer
from . import image
from . import viewport  # 新增
from . import geometry  # 新增
import bpy

# --- 定义宏 Operator：一键执行所有优化 ---
class TOT_OT_RunAllOptimization(bpy.types.Operator):
    """依次运行所有启用的优化流程 (Texture, Geo, Viewport)"""
    bl_idname = "tot.run_all_optimization"
    bl_label = "Run All Optimizations"
    
    def execute(self, context):
        scn = context.scene.tot_props
        
        # 1. Viewport
        if scn.view_lod_enabled:
            bpy.ops.tot.viewport_lod_update()
            
        # 2. Geometry
        if scn.geo_lod_enabled:
            # 自动 Setup (如果还没加修改器)
            bpy.ops.tot.geo_lod_setup()
            # 更新参数
            bpy.ops.tot.geo_lod_update()
            
        # 3. Texture (未来扩展：这里可以加基于距离的贴图缩放逻辑)
        # currently mostly manual in the other panel
        
        self.report({'INFO'}, "All optimizations updated based on camera distance.")
        return {'FINISHED'}

def register():
    bpy.utils.register_class(TOT_OT_RunAllOptimization)

def unregister():
    bpy.utils.unregister_class(TOT_OT_RunAllOptimization)

==================================================
File Path: .\ui\lists.py
==================================================

import bpy

class TOT_UL_ImageStats(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        # 绘制列表的每一行
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            row = layout.row()
            
            # 选择框
            row.prop(item, "image_selected", text="")
            
            # 图片名
            split = row.split(factor=0.6)
            split.label(text=item.tot_image_name, icon='IMAGE_DATA')
            
            # 状态图标 (打包/链接)
            r = split.row()
            if item.packed_img == 1:
                r.label(text="", icon='PACKAGE')
            elif item.packed_img == 2:
                r.label(text="", icon='LINKED')
            
            # 大小
            r.label(text=f"{item.image_size} MB")

        elif self.layout_type == 'GRID':
            layout.alignment = 'CENTER'
            layout.label(text="", icon='IMAGE_DATA')

def register():
    bpy.utils.register_class(TOT_UL_ImageStats)

def unregister():
    bpy.utils.unregister_class(TOT_UL_ImageStats)

==================================================
File Path: .\ui\main_panels.py
==================================================

import bpy

class TOT_PT_MainPanel:
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Optimize" 
    bl_options = {'DEFAULT_CLOSED'}

class TOT_PT_LODManager(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "LOD Manager"
    bl_idname = "TOT_PT_LODManager"
    
    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        #相机选择
        layout.prop(scn, "lod_camera", icon='CAMERA_DATA')
        layout.separator()
        
        # 距离阈值设定 (Zones)
        layout.label(text="Distance Zones (Meters):", icon='TRACKER')
        row = layout.row(align=True)
        row.prop(scn, "lod_dist_0", text="High")
        row.prop(scn, "lod_dist_1", text="Mid")
        row.prop(scn, "lod_dist_2", text="Low")
        
        layout.separator()
        
        # ==========================================================
        # 2. 维度三：视窗优化 (Viewport Optimization)
        # ==========================================================
        box = layout.box()
        header = box.row()
        header.prop(scn, "view_lod_enabled", text="Viewport Optimization", icon='VIEW3D', toggle=True)
        
        if scn.view_lod_enabled:
            col = box.column(align=True)
            # High Zone
            r = col.row()
            r.label(text="0m - High:")
            r.prop(scn, "view_lod0_display", text="")
            # Mid Zone
            r = col.row()
            r.label(text="Mid:")
            r.prop(scn, "view_lod1_display", text="")
            # Low Zone
            r = col.row()
            r.label(text="Low:")
            r.prop(scn, "view_lod2_display", text="")
            # Far Zone
            r = col.row()
            r.label(text="> Far:")
            r.prop(scn, "view_lod3_display", text="")
            
            box.prop(scn, "view_lod3_hide", text="Hide Far Objects")
            
            # 视窗操作按钮
            r = box.row(align=True)
            r.operator("tot.viewport_lod_update", text="Update View", icon='FILE_REFRESH')
            r.operator("tot.viewport_lod_reset", text="Reset", icon='X')

        # ==========================================================
        # 3. 维度二：模型减面 (Geometry LOD - 重构版)
        # ==========================================================
        box = layout.box()
        
        # 头部
        row = box.row()
        row.label(text="Geometry LOD", icon="MOD_DECIM")
        row.prop(scn, "geo_lod_enabled", text="Enable", toggle=True)
        
        if scn.geo_lod_enabled:
            # 1. 方法选择
            row = box.row(align=True)
            row.prop(scn, "geo_lod_method", text="Method")
            
            # 2. 参数显示
            col = box.column(align=True)
            col.prop(scn, "geo_lod_min_faces", text="Min Faces (Safety)")
            
            # 动态显示强度标签
            if scn.geo_lod_method == 'DECIMATE':
                # Decimate 模式：数值是“保留比例”，越小减面越多
                col.prop(scn, "geo_lod_min_ratio", text="Min Ratio (Max Reduction)", slider=True)
            else:
                # GN 模式：数值是“强度因子”，越大减面越多
                # 复用同一个变量，但在逻辑里处理
                col.prop(scn, "geo_lod_min_ratio", text="GN Strength Factor", slider=True)
                col.label(text="Higher Strength = More Merging", icon='INFO')

            # 3. 三大核心按钮 (Setup / Update / Reset)
            row = box.row(align=True)
            row.scale_y = 1.2
            row.operator("tot.geo_lod_setup", text="Setup Modifiers", icon="MODIFIER")
            row.operator("tot.geo_lod_update", text="Update Geometry", icon="PLAY")
            row.operator("tot.geo_lod_reset", text="Reset Geometry", icon="FILE_REFRESH")
            
            # 4. Apply 按钮 (现在支持两种模式)
            row = box.row()
            row.scale_y = 1.2
            # 红色警告色提示这是破坏性操作
            row.alert = True 
            op_text = "Apply Decimate" if scn.geo_lod_method == 'DECIMATE' else "Apply GeoNodes"
            row.operator("tot.geo_lod_apply", text=f"{op_text} (Destructive)", icon="CHECKMARK")
        # ==========================================================
        # 4. 维度一：贴图管理 (Texture - 占位)
        # ==========================================================
        box = layout.box()
        box.label(text="Texture Optimization", icon='TEXTURE')
        # 这里复用之前的 Resize 逻辑，但建议未来整合进 LOD 逻辑
        box.label(text="See Image Resizer Panel below", icon='INFO')
        
# 原来的 Image Resizer 面板保持不变，作为独立工具存在
class TOT_PT_ImageResizer(TOT_PT_MainPanel, bpy.types.Panel):
    bl_label = "Image Tools"
    bl_idname = "TOT_PT_ImageResizer"
    # ... (保持之前的 draw 代码不变) ...
    def draw(self, context):
        layout = self.layout
        scn = context.scene.tot_props
        layout.operator("tot.updateimagelist", text="Scan Images")
        # ... (由于篇幅限制，这里复用之前生成的代码)

classes = (
    TOT_PT_LODManager,
    TOT_PT_ImageResizer,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================
File Path: .\ui\__init__.py
==================================================

from . import lists
from . import main_panels
